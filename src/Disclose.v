(*
Experiments in stating "disclosure" properties of the CVM.

Author:  Adam Petz, ampetz@ku.edu
*)

Require Import Term_Defs Anno_Term_Defs Term LTS Cvm_Impl Cvm_St Trace Main ConcreteEvidence.

Require Import CvmSemantics Appraisal_Evidence Eqb_Evidence Auto AbstractedTypes EqClass Helpers_CvmSemantics (* Disclose_Gen *) External_Facts Axioms_Io.

Require Import StructTactics.

Require Import ErrorStMonad_Coq.

Require Import Coq.Program.Tactics PeanoNat Lia.

Require Import List.
Import ListNotations.

(*
Set Nested Proofs Allowed.
*)

Axiom cvm_thread_in_ev : forall n p ev t e blah,
In ev ([cvm_thread_start n p (copland_compile t) e] ++ blah ++ [cvm_thread_end 0]) -> 
(In ev (cvm_events_core (copland_compile t) p e) \/ 
In ev blah).

Axiom cvm_evidence_exists_remote : forall t p e,
  exists b et, 
  cvm_evidence_core t p e = evc b et.
  
Axiom cvm_thread_start_clear : forall t p e n,
(cvm_thread_start n p (lseqc (aspc CLEAR) (copland_compile t)) e) = 
(cvm_thread_start n p (copland_compile t)) mt.



Fixpoint evsubt_bool (e:Evidence) (e':Evidence): bool :=
  match (eqb_evidence e e') with
  | true => true
  | false =>
    match e' with
    | uu _ _ _ et' => evsubt_bool e et'
    | ss e1 e2 => evsubt_bool e e1 || evsubt_bool e e2 
    | _ => false
    end
  end.

Definition get_targ_plc (ps:ASP_PARAMS) : Plc := 
  match ps with 
  | asp_paramsC _ _ tp _ => tp 
  end.

Definition get_asp_id (ps:ASP_PARAMS) : ASP_ID := 
    match ps with 
    | asp_paramsC i _ _ _ => i 
    end.

(** Evidence Type "subterm" relation modulo encryption. 
    The relation (EvSubTAspEnc e' i p) states that Evidence Type e' 
      makes visible to place p evidence generated by ASP i (modulo encryption).
    Stated another way:  Evidence from ASP i can be viewed "in the clear" by 
      place p with access to e' (modulo decryption by place p).

*)

Inductive EvSubTAspEnc: Evidence -> ASP_ID -> Plc -> Prop :=
| uuSubT_asp_noenc: forall e' p q ps i fwd,
    get_asp_id ps = i -> 
    fwd <> ENCR (* /\ fwd <> COMP *) -> 
    (* TODO: include COMP here for appraisal/cert asps hiding evidence? *)
    EvSubTAspEnc (uu p fwd ps e') i q
| uuSubT_asp_noenc_sub: forall e' p q fwd ps i,
    EvSubTAspEnc e' i q -> 
    fwd <> ENCR -> 
    EvSubTAspEnc (uu p fwd ps e') i q
| uuSubT_asp_enc: forall e' p q ps i,
    get_targ_plc ps = q -> 
    get_asp_id ps = i -> 
    EvSubTAspEnc (uu p ENCR ps e') i q
| uuSubT_asp_enc_sub: forall e' p q ps i,
    EvSubTAspEnc e' i q -> 
    get_targ_plc ps = q -> 
    EvSubTAspEnc (uu p ENCR ps e') i q
| ssSublT: forall e' e'' q i,
    EvSubTAspEnc e' i q ->
    EvSubTAspEnc (ss e' e'') i q
| ssSubrT: forall e' e'' q i,
    EvSubTAspEnc e'' i q ->
    EvSubTAspEnc (ss e' e'') i q.
#[export] Hint Constructors EvSubTAspEnc : core.


Definition evsubt_asp_enc_bool (e:Evidence) (i:ASP_ID) (q:Plc): bool.
Admitted.

Lemma evsubt_asp_enc_prop_bool: forall e i q,
    EvSubTAspEnc e i q -> evsubt_asp_enc_bool e i q = true.
Proof.
Admitted.

Lemma evsubt_asp_enc_bool_prop: forall e i q,
  evsubt_asp_enc_bool e i q = true -> EvSubTAspEnc e i q.
Proof.
Admitted.

Lemma evsubt_asp_enc_bool_prop_iff: forall e i q,
    EvSubTAspEnc e i q <-> evsubt_asp_enc_bool e i q = true.
Proof.
  intros; split.
  apply evsubt_asp_enc_prop_bool.
  apply evsubt_asp_enc_bool_prop.
Qed.



Lemma eqb_asp_params_refl: forall a,
    eqb_asp_params a a = true.
Proof.
  intros. apply eqb_eq_asp_params. auto.
Qed.

Lemma eqb_evidence_refl: forall e,
    eqb_evidence e e = true.
Proof.
  intros. apply eqb_eq_evidence. auto.
Qed.

Lemma eqb_plc_refl `{H : EqClass ID_Type} : forall (p:Plc),
    eqb_plc p p = true.
Proof.
  intros. apply eqb_eq_plc. auto.
Qed.

Lemma eqb_fwd_refl : forall (f:FWD),
    eqb_fwd f f = true.
Proof.
  intros. apply eqb_eq_fwd. auto.
Qed.

Lemma evsubt_prop_bool: forall e e',
    EvSubT e e' -> evsubt_bool e e' = true.
Proof.
  intros.
  generalizeEverythingElse e'.
  induction e'; intros;
    try (invc H; ff; try tauto; rewrite PeanoNat.Nat.eqb_refl; tauto).
  - (* uu case *)
    invc H.
    +
      ff.
      (*
    rewrite PeanoNat.Nat.eqb_refl. *)
    rewrite eqb_asp_params_refl.
    rewrite eqb_evidence_refl.
    rewrite eqb_plc_refl.
    rewrite eqb_fwd_refl.
    ff.
    
    +
      ff.
      assert (evsubt_bool e e' = true) by eauto.
      rewrite H.
      ff.
      
  - (* ss case *)
    ff.
    invc H.
    +
      rewrite eqb_evidence_refl.
      ff.
    +
      erewrite IHe'1.
      ff.
      eassumption.
    +
      erewrite IHe'2.
      ff.
      rewrite Bool.orb_true_r.
      ff.
      eassumption.
Qed.


Lemma evsubt_bool_prop: forall e e',
    evsubt_bool e e' = true -> EvSubT e e'.
Proof.
  intros.
  generalizeEverythingElse e'.
  induction e'; intros.
  -
    ff.
    destruct e; ff.
  -
    ff.
    destruct e; ff.
    rewrite Nat.eqb_eq in *.
    ff.
  - (* uu case *)
    ff.
    destruct e; ff.
    rewrite Bool.andb_true_iff in Heqb.
    rewrite Bool.andb_true_iff in Heqb.
    destruct_conjs.
    rewrite eqb_eq_asp_params in *.
    rewrite Bool.andb_true_iff in H0.
    invc H0.
    apply eqb_eq_plc in H3.
    apply eqb_eq_fwd in H4.
    apply eqb_eq_evidence in H1.
    subst.
    eapply evsub_reflT.
    
  - (* ss case *)
    ff.

     assert (
        (orb (eqb_evidence e (ss e'1 e'2))%bool
            (evsubt_bool e e'1 || evsubt_bool e e'2)) =
    (if eqb_evidence e (ss e'1 e'2)
       then true
     else (evsubt_bool e e'1 || evsubt_bool e e'2)%bool)).
     {
       apply Bool.orb_lazy_alt.
     }
     rewrite H in H0.

     apply Bool.orb_prop in H0.
     invc H0.
    +
      ff.
      apply eqb_eq_evidence in Heqb.
      ff.
    +
      apply Bool.orb_prop in H1.
      invc H1.
      ++
        ff.
      ++
        ff.
Qed.

Lemma evsubt_bool_prop_iff: forall e e',
    EvSubT e e' <-> evsubt_bool e e' = true.
Proof.
  intros; split.
  apply evsubt_prop_bool.
  apply evsubt_bool_prop.
Qed.
  




(* A relation specifying events (Ev) that disclose evidence to other places.
   Technically, we are considering "Evidence Types" (Evidence), but the correspondence of 
   those types to concrete binary evidence values is maintained by the CVM.
 
  Example:  
  discloses_to_remote ev (q,et) says that event ev discloses evidence of type et to place q.

*)

Inductive discloses_to_remote: Ev -> (Plc*Evidence) -> Prop :=
| at_disclose: forall i p q t e,
    discloses_to_remote (req i p q t e) (q,e).         

Definition discloses_aspid_to_remote_enc (q:Plc) (i:ASP_ID) : Prop :=
      forall e reqid p t,
        EvSubTAspEnc e i q ->  (* TODO: check ok to use q here and not freshly quantified var... *)
        (discloses_to_remote (req reqid p q t e) (q, e)).


Definition splitEv_mt (sp:SP) (e:Evidence) : Evidence :=
  match sp with
  | ALL => e
  | NONE => mt
  end.

Fixpoint term_discloses_to_remote (t:Term) (p:Plc) (e:Evidence) (r:(Plc*Evidence)) : bool :=
  match t with
  | att q t' => ((eqb_plc q (fst r)) && (eqb_evidence (snd r) e))  ||      (* (evsubt_bool (snd r) e) *)
                ((eqb_plc p (fst r)) && (eqb_evidence (snd r) (eval t' q e))) ||
               (term_discloses_to_remote t' q e r)
  | lseq t1 t2 => (term_discloses_to_remote t1 p e r) ||
                 (term_discloses_to_remote t2 p (eval t1 p e) r)
  | bseq (sp1,sp2) t1 t2 => (term_discloses_to_remote t1 p (splitEv_mt sp1 e) r) ||
                           (term_discloses_to_remote t2 p (splitEv_mt sp2 e) r)
  | bpar (sp1,sp2) t1 t2 => (term_discloses_to_remote t1 p (splitEv_mt sp1 e) r) ||
                           (term_discloses_to_remote t2 p (splitEv_mt sp2 e) r)
  | _ => false
  end.

Definition term_discloses_aspid_to_remote_enc (t:Term) (p:Plc) (e:Evidence) (i:ASP_ID) (r:Plc) : Prop :=
      exists e',
        EvSubTAspEnc e' i r /\
        ((term_discloses_to_remote t p e (r,e')) = true).

Lemma term_discloses_aspid_to_remote_enc_prop_bool_iff : 
forall t p e i r, 
term_discloses_aspid_to_remote_enc t p e i r <-> 
term_discloses_aspid_to_remote_enc_bool t p e i r = true.
Proof.
Admitted.


Definition cvm_trace_discloses_to_remote (tr:list Ev) (r:Plc) (e:Evidence) : Prop :=
  exists ev,
    (In ev tr) /\

    (
      (exists reqi reqp reqt, 
        ev = (req reqi reqp r reqt e)) \/ 
      (exists rpyi rpyp, 
        ev = (rpy rpyi r rpyp e))
    ).


 Definition cvm_trace_discloses_aspid_to_remote_enc (tr:list Ev) (i:ASP_ID) (r:Plc) : Prop :=
  exists e,
     evsubt_asp_enc_bool e i r = true /\
     cvm_trace_discloses_to_remote tr r e.

Definition events_discloses (annt:AnnoTerm) (p:Plc) (e:Evidence) (r:Plc) (e':Evidence): Prop :=
    exists ev,
      (
        (* annoP annt t /\  *)
        events annt p e ev /\
        (
          (exists reqi reqp reqt, 
            ev = (req reqi reqp r reqt e')) \/ 
          (exists rpyi rpyp, 
            ev = (rpy rpyi r rpyp e'))
        )
      ).

Definition events_discloses_aspid_enc (annt:AnnoTerm) (p:Plc) (e:Evidence) (i:ASP_ID) (r:Plc): Prop :=
  exists reqe,
     evsubt_asp_enc_bool reqe i r = true /\
     events_discloses annt p e r reqe.


Lemma term_disc_remote_enc: forall t p e i r p0,
          term_discloses_aspid_to_remote_enc t p e i r ->
          term_discloses_aspid_to_remote_enc <{ @ p [t] }> p0 e i r.
Proof.
  intros.
  invc H.
  destruct_conjs.
  econstructor.
  split.
  - 
    eassumption.
  -
    ff.
    find_rewrite.
    apply Bool.orb_true_r.
Qed.

Lemma term_disc_lseq_l_enc: forall t1 t2 p e i r,
          term_discloses_aspid_to_remote_enc t1 p e i r ->
          term_discloses_aspid_to_remote_enc <{ t1 -> t2 }> p e i r.
Proof.
  intros.
  invc H.
  destruct_conjs.
  econstructor.
  split.
  - 
    eassumption.
  -
    ff.
    find_rewrite.
    apply Bool.orb_true_l.
Qed.

Lemma term_disc_lseq_r_enc: forall t1 t2 p e i r,
          term_discloses_aspid_to_remote_enc t2 p (eval t1 p e) i r ->
          term_discloses_aspid_to_remote_enc <{ t1 -> t2 }> p e i r.
Proof.
  intros.
  invc H.
  destruct_conjs.
  econstructor.
  split.
  - 
    eassumption.
  -
    ff.
    find_rewrite.
    apply Bool.orb_true_r.
Qed.

Lemma term_disc_bseq_l_enc: forall t1 t2 p e i r s,
          term_discloses_aspid_to_remote_enc t1 p (splitEv_T_l s e) i r ->
          term_discloses_aspid_to_remote_enc (bseq s t1 t2) p e i r.
Proof.
  intros.
  invc H.
  destruct_conjs.
  econstructor.
  split.
  - 
    eassumption.
  -
    ff.
    subst.
    destruct s0;
    destruct s1;
      
      simpl in *;
      rewrite H0;
      
      rewrite Bool.orb_true_l;
      auto.
Qed.

Lemma term_disc_bseq_r_enc: forall t1 t2 p e i r s,
          term_discloses_aspid_to_remote_enc t2 p (splitEv_T_r s e) i r ->
          term_discloses_aspid_to_remote_enc (bseq s t1 t2) p e i r.
Proof.
  intros.
  invc H.
  destruct_conjs.
  econstructor.
  split.
  - 
    eassumption.
  -
    ff.
    subst.
    destruct s0;
    destruct s1;
      
      simpl in *;
      rewrite H0;
      
      rewrite Bool.orb_true_r;
      auto.
Qed.

Lemma term_disc_bpar_l_enc: forall t1 t2 p e i r s,
          term_discloses_aspid_to_remote_enc t1 p (splitEv_T_l s e) i r ->
          term_discloses_aspid_to_remote_enc (bpar s t1 t2) p e i r.
Proof.
  intros.
  invc H.
  destruct_conjs.
  econstructor.
  split.
  - 
    eassumption.
  -
    ff.
    subst.
    destruct s0;
    destruct s1;
      
      simpl in *;
      rewrite H0;
      
      rewrite Bool.orb_true_l;
      auto.
Qed.


Lemma term_disc_bpar_r_enc: forall t1 t2 p e i r s,
          term_discloses_aspid_to_remote_enc t2 p (splitEv_T_r s e) i r ->
          term_discloses_aspid_to_remote_enc (bpar s t1 t2) p e i r.
Proof.
  intros.
  invc H.
  destruct_conjs.
  econstructor.
  split.
  - 
    eassumption.
  -
    ff.
    subst.
    destruct s0;
    destruct s1;
      
      simpl in *;
      rewrite H0;
      
      rewrite Bool.orb_true_r;
      auto.
Qed.

Lemma term_discloses_respects_events : forall annt t p e r H2,
      annoP annt t -> 
      events_discloses annt p e r H2 ->
      term_discloses_to_remote t p e (r, H2) = true.
Proof.
  intros.
  unfold not in * ; intros.
  (*
  unfold events_discloses_aspid in *.
  (*
  assert (exists annt cvmi, annoP_indexed annt t 0 cvmi). admit.
  destruct_conjs.
  specialize (H0 H1 H2 H3). *)
  destruct_conjs.
  subst.
  *)

  generalizeEverythingElse t.
  induction t; intros.

  - (* asp case *)
    invc H.
    destruct_conjs.
    invc H0.
    destruct_conjs.
    door;
    repeat ff.
  - (* at case *)
    invc H0.
    destruct_conjs.

    door.
    + (* req case *)

    ff.
    invc H.
    destruct_conjs.

    invc H5; try solve_by_inversion.
    ff.
    invc H0.
    ++
       assert (eqb_plc r r = true).
    {
      eapply eqb_eq_plc; eauto.
    }
        assert (eqb_evidence H2 H2 = true).
    {
      eapply eqb_evidence_refl.
    }

    find_rewrite.
    find_rewrite.
    simpl.
    tauto.
    ++
      assert (term_discloses_to_remote t p e (r, H2) = true).
      {
        eapply IHt with (p:=p).
        econstructor.
        repeat eexists.
        eassumption.
        econstructor.
        repeat eexists.
        eassumption.
        left.
        eauto.
      }
      find_rewrite.
      rewrite Bool.orb_true_r.
      auto.

    + (* rpy case *)

    ff.
    invc H.
    destruct_conjs.

    invc H4.
    ff.
    invc H0.
    ++ 

    assert (term_discloses_to_remote t p e (r, H2) = true).
    {
      eapply IHt with (p:=p).
      econstructor.
      repeat eexists.
      eassumption.
      econstructor.
      repeat eexists.
      eassumption.
      right.
      eauto.
    }
    find_rewrite.
    rewrite Bool.orb_true_r.
    auto.




    ++





       assert (eqb_plc r r = true).
    {
      eapply eqb_eq_plc; eauto.
    }
        assert (eqb_evidence (aeval a H3 e) (eval t H3 e) = true).
    {
      erewrite eval_aeval.
      rewrite Heqp1.
      simpl.
      eapply eqb_evidence_refl.
    }

    find_rewrite.
    find_rewrite.
    rewrite Bool.orb_true_r.
    simpl.
    tauto.

  - (* lseq case *)

    invc H.
    destruct_conjs.

    invc H3.
    repeat break_let.
    ff.

    invc H0.
    destruct_conjs.

    door.
    + (* req case *)



    subst.
    invc H0.
    ++

      assert (term_discloses_to_remote t1 p e (r, H2) = true).
      {

      (* left subterm *)
      eapply IHt1 with (p:=p). (* with (H7 := (uu p0 f (asp_paramsC a0 l p1 t) e0)). *)
      econstructor.
      repeat eexists.
      eassumption.

      econstructor.
      repeat eexists.
      eassumption.
      left; eauto.
      }
      find_rewrite.
      simpl.
      tauto.
      
    ++ (* right subterm *)

      assert (term_discloses_to_remote t2 p (eval t1 p e) (r, H2) = true).
      {
         assert (aeval a p e = eval t1 p e).
      {
        erewrite eval_aeval.
        rewrite Heqp0.
        simpl.
        tauto.
      }
      rewrite <- H0.
      eapply IHt2 with (p:=p). (* with (H7 := (uu p0 f (asp_paramsC a0 l p1 t) e0)). *)
      econstructor.
      repeat eexists.
      eassumption.

      econstructor.
      repeat eexists.
      eassumption.
      left; eauto.
      }
      find_rewrite.

      rewrite Bool.orb_true_r.
      tauto.

   + (* rpy case *)



    subst.
    invc H0.
    ++

      assert (term_discloses_to_remote t1 p e (r, H2) = true).
      {

      (* left subterm *)
      eapply IHt1 with (p:=p). (* with (H7 := (uu p0 f (asp_paramsC a0 l p1 t) e0)). *)
      econstructor.
      repeat eexists.
      eassumption.

      econstructor.
      repeat eexists.
      eassumption.
      right; eauto.
      }
      find_rewrite.
      simpl.
      tauto.
      
    ++ (* right subterm *)

      assert (term_discloses_to_remote t2 p (eval t1 p e) (r, H2) = true).
      {
         assert (aeval a p e = eval t1 p e).
      {
        erewrite eval_aeval.
        rewrite Heqp0.
        simpl.
        tauto.
      }
      rewrite <- H0.
      eapply IHt2 with (p:=p). (* with (H7 := (uu p0 f (asp_paramsC a0 l p1 t) e0)). *)
      econstructor.
      repeat eexists.
      eassumption.

      econstructor.
      repeat eexists.
      eassumption.
      right; eauto.
      }
      find_rewrite.

      rewrite Bool.orb_true_r.
      tauto.

  - (* bseq case *)

    invc H.
    destruct_conjs.

    invc H3.
    repeat break_let.
    ff.

    invc H0.
    destruct_conjs.
    subst.
    destruct s0; destruct s1; ff.

    +

    door; subst. 

    ++ (* req case *)
      
      invc H.
      +++
    

      assert (term_discloses_to_remote t1 p e (r, H2) = true).
      {

      (* left subterm *)
      eapply IHt1 with (p:=p). (* with (H7 := (uu p0 f (asp_paramsC a0 l p1 t) e0)). *)
      econstructor.
      repeat eexists.
      eassumption.
      ff.
      econstructor.
      repeat eexists.
      eassumption.
      eauto.
      }
      find_rewrite.
      simpl.
      tauto.
      +++
          assert (term_discloses_to_remote t2 p e (r, H2) = true).
      {

      (* left subterm *)
      eapply IHt2 with (p:=p). (* with (H7 := (uu p0 f (asp_paramsC a0 l p1 t) e0)). *)
      econstructor.
      repeat eexists.
      eassumption.
      ff.
      econstructor.
      repeat eexists.
      eassumption.
      eauto.
      }
      find_rewrite.
         rewrite Bool.orb_true_r.
         tauto.

    ++ (* rpy case *)


    invc H.
    +++
  

    assert (term_discloses_to_remote t1 p e (r, H2) = true).
    {

    (* left subterm *)
    eapply IHt1 with (p:=p). (* with (H7 := (uu p0 f (asp_paramsC a0 l p1 t) e0)). *)
    econstructor.
    repeat eexists.
    eassumption.
    ff.
    econstructor.
    repeat eexists.
    eassumption.
    eauto.
    }
    find_rewrite.
    simpl.
    tauto.
    +++
        assert (term_discloses_to_remote t2 p e (r, H2) = true).
    {

    (* left subterm *)
    eapply IHt2 with (p:=p). (* with (H7 := (uu p0 f (asp_paramsC a0 l p1 t) e0)). *)
    econstructor.
    repeat eexists.
    eassumption.
    ff.
    econstructor.
    repeat eexists.
    eassumption.
    eauto.
    }
    find_rewrite.
       rewrite Bool.orb_true_r.
       tauto.



    +

       door; subst. 
   
       ++ (* req case *)
         
         invc H.
         +++
       
   
         assert (term_discloses_to_remote t1 p e (r, H2) = true).
         {
   
         (* left subterm *)
         eapply IHt1 with (p:=p). (* with (H7 := (uu p0 f (asp_paramsC a0 l p1 t) e0)). *)
         econstructor.
         repeat eexists.
         eassumption.
         ff.
         econstructor.
         repeat eexists.
         eassumption.
         eauto.
         }
         find_rewrite.
         simpl.
         tauto.
         +++
             assert (term_discloses_to_remote t2 p mt (r, H2) = true).
         {
   
         (* left subterm *)
         eapply IHt2 with (p:=p). (* with (H7 := (uu p0 f (asp_paramsC a0 l p1 t) e0)). *)
         econstructor.
         repeat eexists.
         eassumption.
         ff.
         econstructor.
         repeat eexists.
         eassumption.
         eauto.
         }
         find_rewrite.
            rewrite Bool.orb_true_r.
            tauto.
   
       ++ (* rpy case *)
   
   
       invc H.
       +++
     
   
       assert (term_discloses_to_remote t1 p e (r, H2) = true).
       {
   
       (* left subterm *)
       eapply IHt1 with (p:=p). (* with (H7 := (uu p0 f (asp_paramsC a0 l p1 t) e0)). *)
       econstructor.
       repeat eexists.
       eassumption.
       ff.
       econstructor.
       repeat eexists.
       eassumption.
       eauto.
       }
       find_rewrite.
       simpl.
       tauto.
       +++
           assert (term_discloses_to_remote t2 p mt (r, H2) = true).
       {
   
       (* left subterm *)
       eapply IHt2 with (p:=p). (* with (H7 := (uu p0 f (asp_paramsC a0 l p1 t) e0)). *)
       econstructor.
       repeat eexists.
       eassumption.
       ff.
       econstructor.
       repeat eexists.
       eassumption.
       eauto.
       }
       find_rewrite.
          rewrite Bool.orb_true_r.
          tauto.


    +

          door; subst. 
      
          ++ (* req case *)
            
            invc H.
            +++
          
      
            assert (term_discloses_to_remote t1 p mt (r, H2) = true).
            {
      
            (* left subterm *)
            eapply IHt1 with (p:=p). (* with (H7 := (uu p0 f (asp_paramsC a0 l p1 t) e0)). *)
            econstructor.
            repeat eexists.
            eassumption.
            ff.
            econstructor.
            repeat eexists.
            eassumption.
            eauto.
            }
            find_rewrite.
            simpl.
            tauto.
            +++
                assert (term_discloses_to_remote t2 p e (r, H2) = true).
            {
      
            (* left subterm *)
            eapply IHt2 with (p:=p). (* with (H7 := (uu p0 f (asp_paramsC a0 l p1 t) e0)). *)
            econstructor.
            repeat eexists.
            eassumption.
            ff.
            econstructor.
            repeat eexists.
            eassumption.
            eauto.
            }
            find_rewrite.
               rewrite Bool.orb_true_r.
               tauto.
      
          ++ (* rpy case *)
      
      
          invc H.
          +++
        
      
          assert (term_discloses_to_remote t1 p mt (r, H2) = true).
          {
      
          (* left subterm *)
          eapply IHt1 with (p:=p). (* with (H7 := (uu p0 f (asp_paramsC a0 l p1 t) e0)). *)
          econstructor.
          repeat eexists.
          eassumption.
          ff.
          econstructor.
          repeat eexists.
          eassumption.
          eauto.
          }
          find_rewrite.
          simpl.
          tauto.
          +++
              assert (term_discloses_to_remote t2 p e (r, H2) = true).
          {
      
          (* left subterm *)
          eapply IHt2 with (p:=p). (* with (H7 := (uu p0 f (asp_paramsC a0 l p1 t) e0)). *)
          econstructor.
          repeat eexists.
          eassumption.
          ff.
          econstructor.
          repeat eexists.
          eassumption.
          eauto.
          }
          find_rewrite.
             rewrite Bool.orb_true_r.
             tauto.

    +

             door; subst. 
         
             ++ (* req case *)
               
               invc H.
               +++
             
         
               assert (term_discloses_to_remote t1 p mt (r, H2) = true).
               {
         
               (* left subterm *)
               eapply IHt1 with (p:=p). (* with (H7 := (uu p0 f (asp_paramsC a0 l p1 t) e0)). *)
               econstructor.
               repeat eexists.
               eassumption.
               ff.
               econstructor.
               repeat eexists.
               eassumption.
               eauto.
               }
               find_rewrite.
               simpl.
               tauto.
               +++
                   assert (term_discloses_to_remote t2 p mt (r, H2) = true).
               {
         
               (* left subterm *)
               eapply IHt2 with (p:=p). (* with (H7 := (uu p0 f (asp_paramsC a0 l p1 t) e0)). *)
               econstructor.
               repeat eexists.
               eassumption.
               ff.
               econstructor.
               repeat eexists.
               eassumption.
               eauto.
               }
               find_rewrite.
                  rewrite Bool.orb_true_r.
                  tauto.
         
             ++ (* rpy case *)
         
         
             invc H.
             +++
           
         
             assert (term_discloses_to_remote t1 p mt (r, H2) = true).
             {
         
             (* left subterm *)
             eapply IHt1 with (p:=p). (* with (H7 := (uu p0 f (asp_paramsC a0 l p1 t) e0)). *)
             econstructor.
             repeat eexists.
             eassumption.
             ff.
             econstructor.
             repeat eexists.
             eassumption.
             eauto.
             }
             find_rewrite.
             simpl.
             tauto.
             +++
                 assert (term_discloses_to_remote t2 p mt (r, H2) = true).
             {
         
             (* left subterm *)
             eapply IHt2 with (p:=p). (* with (H7 := (uu p0 f (asp_paramsC a0 l p1 t) e0)). *)
             econstructor.
             repeat eexists.
             eassumption.
             ff.
             econstructor.
             repeat eexists.
             eassumption.
             eauto.
             }
             find_rewrite.
                rewrite Bool.orb_true_r.
                tauto.

    - (* bpar case *)

    invc H.
    destruct_conjs.

    invc H3.
    repeat break_let.
    ff.

    invc H0.
    destruct_conjs.
    subst.
    destruct s0; destruct s1; ff.

    +

    door; subst. 

    ++ (* req case *)
      
      invc H.
      +++
    

      assert (term_discloses_to_remote t1 p e (r, H2) = true).
      {

      (* left subterm *)
      eapply IHt1 with (p:=p). (* with (H7 := (uu p0 f (asp_paramsC a0 l p1 t) e0)). *)
      econstructor.
      repeat eexists.
      eassumption.
      ff.
      econstructor.
      repeat eexists.
      eassumption.
      eauto.
      }
      find_rewrite.
      simpl.
      tauto.
      +++
          assert (term_discloses_to_remote t2 p e (r, H2) = true).
      {

      (* left subterm *)
      eapply IHt2 with (p:=p). (* with (H7 := (uu p0 f (asp_paramsC a0 l p1 t) e0)). *)
      econstructor.
      repeat eexists.
      eassumption.
      ff.
      econstructor.
      repeat eexists.
      eassumption.
      eauto.
      }
      find_rewrite.
          rewrite Bool.orb_true_r.
          tauto.

    ++ (* rpy case *)


    invc H.
    +++
  

    assert (term_discloses_to_remote t1 p e (r, H2) = true).
    {

    (* left subterm *)
    eapply IHt1 with (p:=p). (* with (H7 := (uu p0 f (asp_paramsC a0 l p1 t) e0)). *)
    econstructor.
    repeat eexists.
    eassumption.
    ff.
    econstructor.
    repeat eexists.
    eassumption.
    eauto.
    }
    find_rewrite.
    simpl.
    tauto.
    +++
        assert (term_discloses_to_remote t2 p e (r, H2) = true).
    {

    (* left subterm *)
    eapply IHt2 with (p:=p). (* with (H7 := (uu p0 f (asp_paramsC a0 l p1 t) e0)). *)
    econstructor.
    repeat eexists.
    eassumption.
    ff.
    econstructor.
    repeat eexists.
    eassumption.
    eauto.
    }
    find_rewrite.
        rewrite Bool.orb_true_r.
        tauto.



    +

        door; subst. 
    
        ++ (* req case *)
          
          invc H.
          +++
        
    
          assert (term_discloses_to_remote t1 p e (r, H2) = true).
          {
    
          (* left subterm *)
          eapply IHt1 with (p:=p). (* with (H7 := (uu p0 f (asp_paramsC a0 l p1 t) e0)). *)
          econstructor.
          repeat eexists.
          eassumption.
          ff.
          econstructor.
          repeat eexists.
          eassumption.
          eauto.
          }
          find_rewrite.
          simpl.
          tauto.
          +++
              assert (term_discloses_to_remote t2 p mt (r, H2) = true).
          {
    
          (* left subterm *)
          eapply IHt2 with (p:=p). (* with (H7 := (uu p0 f (asp_paramsC a0 l p1 t) e0)). *)
          econstructor.
          repeat eexists.
          eassumption.
          ff.
          econstructor.
          repeat eexists.
          eassumption.
          eauto.
          }
          find_rewrite.
            rewrite Bool.orb_true_r.
            tauto.
    
        ++ (* rpy case *)
    
    
        invc H.
        +++
      
    
        assert (term_discloses_to_remote t1 p e (r, H2) = true).
        {
    
        (* left subterm *)
        eapply IHt1 with (p:=p). (* with (H7 := (uu p0 f (asp_paramsC a0 l p1 t) e0)). *)
        econstructor.
        repeat eexists.
        eassumption.
        ff.
        econstructor.
        repeat eexists.
        eassumption.
        eauto.
        }
        find_rewrite.
        simpl.
        tauto.
        +++
            assert (term_discloses_to_remote t2 p mt (r, H2) = true).
        {
    
        (* left subterm *)
        eapply IHt2 with (p:=p). (* with (H7 := (uu p0 f (asp_paramsC a0 l p1 t) e0)). *)
        econstructor.
        repeat eexists.
        eassumption.
        ff.
        econstructor.
        repeat eexists.
        eassumption.
        eauto.
        }
        find_rewrite.
          rewrite Bool.orb_true_r.
          tauto.


    +

          door; subst. 
      
          ++ (* req case *)
            
            invc H.
            +++
          
      
            assert (term_discloses_to_remote t1 p mt (r, H2) = true).
            {
      
            (* left subterm *)
            eapply IHt1 with (p:=p). (* with (H7 := (uu p0 f (asp_paramsC a0 l p1 t) e0)). *)
            econstructor.
            repeat eexists.
            eassumption.
            ff.
            econstructor.
            repeat eexists.
            eassumption.
            eauto.
            }
            find_rewrite.
            simpl.
            tauto.
            +++
                assert (term_discloses_to_remote t2 p e (r, H2) = true).
            {
      
            (* left subterm *)
            eapply IHt2 with (p:=p). (* with (H7 := (uu p0 f (asp_paramsC a0 l p1 t) e0)). *)
            econstructor.
            repeat eexists.
            eassumption.
            ff.
            econstructor.
            repeat eexists.
            eassumption.
            eauto.
            }
            find_rewrite.
                rewrite Bool.orb_true_r.
                tauto.
      
          ++ (* rpy case *)
      
      
          invc H.
          +++
        
      
          assert (term_discloses_to_remote t1 p mt (r, H2) = true).
          {
      
          (* left subterm *)
          eapply IHt1 with (p:=p). (* with (H7 := (uu p0 f (asp_paramsC a0 l p1 t) e0)). *)
          econstructor.
          repeat eexists.
          eassumption.
          ff.
          econstructor.
          repeat eexists.
          eassumption.
          eauto.
          }
          find_rewrite.
          simpl.
          tauto.
          +++
              assert (term_discloses_to_remote t2 p e (r, H2) = true).
          {
      
          (* left subterm *)
          eapply IHt2 with (p:=p). (* with (H7 := (uu p0 f (asp_paramsC a0 l p1 t) e0)). *)
          econstructor.
          repeat eexists.
          eassumption.
          ff.
          econstructor.
          repeat eexists.
          eassumption.
          eauto.
          }
          find_rewrite.
              rewrite Bool.orb_true_r.
              tauto.

    +

              door; subst. 
          
              ++ (* req case *)
                
                invc H.
                +++
              
          
                assert (term_discloses_to_remote t1 p mt (r, H2) = true).
                {
          
                (* left subterm *)
                eapply IHt1 with (p:=p). (* with (H7 := (uu p0 f (asp_paramsC a0 l p1 t) e0)). *)
                econstructor.
                repeat eexists.
                eassumption.
                ff.
                econstructor.
                repeat eexists.
                eassumption.
                eauto.
                }
                find_rewrite.
                simpl.
                tauto.
                +++
                    assert (term_discloses_to_remote t2 p mt (r, H2) = true).
                {
          
                (* left subterm *)
                eapply IHt2 with (p:=p). (* with (H7 := (uu p0 f (asp_paramsC a0 l p1 t) e0)). *)
                econstructor.
                repeat eexists.
                eassumption.
                ff.
                econstructor.
                repeat eexists.
                eassumption.
                eauto.
                }
                find_rewrite.
                  rewrite Bool.orb_true_r.
                  tauto.
          
              ++ (* rpy case *)
          
          
              invc H.
              +++
            
          
              assert (term_discloses_to_remote t1 p mt (r, H2) = true).
              {
          
              (* left subterm *)
              eapply IHt1 with (p:=p). (* with (H7 := (uu p0 f (asp_paramsC a0 l p1 t) e0)). *)
              econstructor.
              repeat eexists.
              eassumption.
              ff.
              econstructor.
              repeat eexists.
              eassumption.
              eauto.
              }
              find_rewrite.
              simpl.
              tauto.
              +++
                  assert (term_discloses_to_remote t2 p mt (r, H2) = true).
              {
          
              (* left subterm *)
              eapply IHt2 with (p:=p). (* with (H7 := (uu p0 f (asp_paramsC a0 l p1 t) e0)). *)
              econstructor.
              repeat eexists.
              eassumption.
              ff.
              econstructor.
              repeat eexists.
              eassumption.
              eauto.
              }
              find_rewrite.
                rewrite Bool.orb_true_r.
                tauto.
Qed.


Lemma fdfdfd: forall Q P: Prop,
    (P -> Q) ->
    (~Q -> ~P).
Proof.
  intros.
  unfold not in *.
  intros.
  apply H0. apply H. eassumption.
Qed.

Lemma events_respects_term_disclosure: forall t p q e r annt,
    annoP annt t -> 

  (~ (term_discloses_to_remote t p e (q,r) = true)) ->

  ~ (events_discloses annt p e q r).
Proof.
  intros t p q e r annt H.
  apply fdfdfd.
  intros.
  eapply term_discloses_respects_events; eauto.
Qed.

(*
Lemma events_respects_term_disclosure_aspid: forall t p e i r annt,
    annoP annt t -> 

  ~ (term_discloses_aspid_to_remote t p e i r) ->

  ~ (events_discloses_aspid annt p e i r).
Proof.
  intros.
  unfold term_discloses_aspid_to_remote in *.
  unfold events_discloses_aspid in *.
  unfold not in H0.
  unfold not in *.
  intros.
  apply H0.
  destruct_conjs.
  exists H1. exists H2.
  split; try eassumption.
  split.
  rewrite evsubt_bool_prop_iff.
  eassumption.

  eapply term_discloses_respects_events; eauto.
Qed.
*)

Lemma events_respects_term_disclosure_aspid_enc: forall t p e i r annt,
    annoP annt t -> 

  ~ (term_discloses_aspid_to_remote_enc t p e i r) ->

  ~ (events_discloses_aspid_enc annt p e i r).
Proof.
  intros.
  unfold term_discloses_aspid_to_remote_enc in *.
  unfold events_discloses_aspid_enc in *.
  unfold not in H0.
  unfold not in *.
  intros.
  apply H0.
  destruct_conjs.
  exists H1.
  split; try eassumption.

  rewrite evsubt_asp_enc_bool_prop_iff.
  eassumption.

  eapply term_discloses_respects_events; eauto.
Qed.

Lemma fufu : forall t1 cvmi p ct e ac ac' st_evid r0 e0 blah, 
build_cvmP (copland_compile t1)
    {|
      st_ev := evc [] mt;
      st_trace := [Term_Defs.split cvmi p; cvm_thread_start 0 p ct e];
      st_pl := p;
      st_evid := S cvmi;
      st_AM_config := ac
    |} (resultC tt)
    {|
      st_ev := evc r0 e0;
      st_trace :=
        Term_Defs.split cvmi p :: (cvm_thread_start 0 p ct e) :: blah;
      st_pl := p;
      st_evid := st_evid;
      st_AM_config := ac'
    |}
    =
    build_cvmP (copland_compile t1)
    {|
      st_ev := evc [] mt;
      st_trace := [Term_Defs.split cvmi p; cvm_thread_start 0 p ct e];
      st_pl := p;
      st_evid := S cvmi;
      st_AM_config := ac
    |} (resultC tt)
    {|
      st_ev := evc r0 e0;
      st_trace :=
        ([Term_Defs.split cvmi p; cvm_thread_start 0 p ct e] ++ blah);
      st_pl := p;
      st_evid := st_evid;
      st_AM_config := ac'
    |}.
Proof.
  ff.
  eauto.
Qed.




Lemma cvm_implies_events: forall t annt e e' bits bits' p p' cvmi cvmi' cvm_tr ev ac ac',
    annoP_indexed annt t cvmi cvmi'->

    build_cvmP (copland_compile t)
         {| st_ev := evc bits e; st_trace := []; st_pl := p; st_evid := cvmi; st_AM_config := ac |} 
         (resultC tt) {| st_ev := evc bits' e'; st_trace := cvm_tr; st_pl := p'; st_evid := cvmi'; st_AM_config := ac' |} ->

    In ev cvm_tr ->

    events annt p e ev.
Proof.
  intros.
  generalizeEverythingElse t.
  induction t; intros.
  - (* asp case *)
    wrap_ccp_anno;
    repeat Auto.ff;
    destruct a; invc H; repeat Auto.ff;
      wrap_ccp_anno;
      repeat Auto.ff;
      try destruct s; wrap_ccp_anno;
      try destruct f;
      try destruct H1;
      subst;
      try solve_by_inversion;
    
      try (econstructor; econstructor; reflexivity).
  -
    wrap_ccp_anno.
    ff.
    unfold Cvm_Monad.doRemote_session' in *;
    repeat Auto.ff.

    assert (n = cvmi + event_id_span' t + 1) by lia.
    subst.
    clear H6.
   
    assert (t = unanno a) as H11.
    {
      invc Heqp1.
      
      erewrite <- anno_unanno at 1.
      rewrite H0.
      tauto.
    }


    door.
    +
      rewrite <- H0.
      rewrite H11.
      apply evtsattreq.
      auto.
    +
      assert ( (In ev (cvm_events t p e)) \/
               ev = (rpy (cvmi + 1 + event_id_span' t) p' p (eval t p e)
                         (* (get_et (IO_Stubs.doRemote_session t p (evc bits e))) *) )
             ).
      {

        apply in_app_or in H0.
        door.
        +
          left; eauto.
        +
          right.
          invc H0;
            try auto;
            try solve_by_inversion.
      }
      
      door.

      assert (
              build_cvm (copland_compile t)
                    {| st_ev := (evc bits e);
                       st_trace := [];
                       st_pl := p;
                       st_evid := (S cvmi); st_AM_config := ac' |} =
    (resultC tt,
     {| st_ev := cvm_evidence_core (copland_compile t) p (evc bits e);
        st_trace := cvm_events_core (copland_compile t) p (get_et (evc bits e));
        st_pl := p;
        st_evid := ( (S cvmi) + event_id_span (copland_compile t));
        st_AM_config := ac'
     |})).
      apply build_cvm_external.

      destruct (cvm_evidence_core (copland_compile t) p (evc bits e)).
      unfold cvm_events in *.


      
      econstructor.

      eapply IHt; [ | simpl in *; econstructor; eauto | eauto ].
      2: {
        subst; rewrite eval_aeval'; apply evtsattrpy;
        simpl; lia.
      }
      econstructor.

      invc Heqp1.
      repeat ff.
      rewrite <- event_id_spans_same.
      simpl in *.
      assert (S (cvmi + event_id_span' (unanno a)) =
              cvmi + event_id_span' (unanno a) + 1) by lia.
      rewrite H4.
      eassumption.
  - (* alseq case *)
    invc H.
    edestruct alseq_decomp; eauto.
    destruct_conjs.
    fold copland_compile in *.

    inversion H2.
    subst.
    ff.
    do_anno_indexed_redo.
    do_anno_indexed_redo.
    
    assert (n = H4).
    {
      eapply anno_span_cvm; eauto;
      econstructor; eauto.
    }
    subst.

    
    destruct x.
     

    assert (In ev H \/ In ev H7).
    {
      apply in_app_or in H1.
        door.
        +
          left; eauto.
        +
          right.
          invc H0;
            try auto;
            try solve_by_inversion.
    }

    door.
    +
      apply evtslseql.
      eapply IHt1.
      econstructor.
      eassumption.
      eassumption.
      eassumption.
    +

      

    assert (e0 = aeval a p e).
      {
      rewrite <- eval_aeval'.
      assert (t1 = unanno a).
    {
      symmetry.
      invc Heqp1.
      erewrite <- anno_unanno.
      rewrite Heqp2.
      tauto.
    }
    eapply cvm_refines_lts_evidence.
    econstructor; eauto.
    rewrite <- H9.
    eassumption.
      }
      rewrite H9 in H8.
      

      assert (p = H3).
      {
        invc H6.
        do_pl_immut.
        congruence.
      }
      

      
      invc Heqp3.
      apply evtslseqr.
      eapply IHt2.
      econstructor.
      eassumption.
      eassumption.
      eassumption.
  - (* abseq case *)
    wrap_ccp_anno;
    repeat Auto.ff;
    wrap_ccp_anno;
    repeat Auto.ff.
    +

    assert (n = st_evid1).
    {
      assert (cvmi+1 = S cvmi) by lia.
      find_rewrite.
      eapply span_cvm.
      eassumption.
      econstructor; tauto.
      invc Heqp0.
      eassumption.
    }
    subst.

    assert (n0 = st_evid) by lia.
    
    repeat do_anno_redo.
    
    do_suffix blah.
    do_suffix blah'.
    destruct_conjs; subst.
    repeat do_restl.

    assert (ev = Term_Defs.split cvmi st_pl0 \/
            (In ev blah') \/
            (In ev blah) \/
            ev = join st_evid st_pl0).
    {
      apply in_app_or in H1.
      door.
      +
        
        apply in_app_or in H0.
        door.
        ++
          apply in_app_or in H0.
          door.
          +++
            invc H0; try eauto; try solve_by_inversion.
          +++
            eauto.
        ++
          eauto.
      +
        invc H0; try eauto; try solve_by_inversion.
    }

    door.
    subst.
    apply evtsbseqsplit.
    tauto.

    door.
    ff.

    apply evtsbseql.
    simpl.
    assert (S cvmi = cvmi + 1) by lia.
    rewrite <- H3 in *.
    subst.
    eapply IHt1.
    eassumption.
    eapply restl.
    assert (Term_Defs.split cvmi st_pl0 :: blah' = 
    [Term_Defs.split cvmi st_pl0] ++ blah'). 
    {
      intuition.
    }
    repeat find_rewrite.
    eassumption.
    eassumption.


    door.

    apply evtsbseqr.
    simpl.

    eapply IHt2.
    eassumption.
    eapply restl.
    eassumption.
    eassumption.

    subst.

    apply evtsbseqjoin.
    simpl.
    lia.

    +
          assert (n = st_evid1).
    {
      assert (cvmi+1 = S cvmi) by lia.
      find_rewrite.
      eapply span_cvm.
      eassumption.
      econstructor; tauto.
      invc Heqp0.
      eassumption.
    }
    subst.

    assert (n0 = st_evid) by lia.
    
    repeat do_anno_redo.
    
    do_suffix blah.
    do_suffix blah'.
    destruct_conjs; subst.
    repeat do_restl.

    assert (ev = Term_Defs.split cvmi st_pl0 \/
            (In ev blah') \/
            (In ev blah) \/
            ev = join st_evid st_pl0).
    {
            apply in_app_or in H1.
      door.
      +
        
        apply in_app_or in H0.
        door.
        ++
          apply in_app_or in H0.
          door.
          +++
            invc H0; try eauto; try solve_by_inversion.
          +++
            eauto.
        ++
          eauto.
      +
        invc H0; try eauto; try solve_by_inversion.
    }
    door.
    subst.
    apply evtsbseqsplit.
    tauto.

    door.
    ff.

    apply evtsbseql.
    simpl.
    assert (S cvmi = cvmi + 1) by lia.
    rewrite <- H3 in *.
    subst.
    eapply IHt1.
    eassumption.
    eapply restl.
    assert (Term_Defs.split cvmi st_pl0 :: blah' = 
    [Term_Defs.split cvmi st_pl0] ++ blah'). 
    {
      intuition.
    }
    repeat find_rewrite.
    eassumption.
    eassumption.


    door.

    apply evtsbseqr.
    simpl.

    eapply IHt2.
    eassumption.
    eapply restl.
    eassumption.
    eassumption.

    subst.

    apply evtsbseqjoin.
    simpl.
    lia.

    +
          assert (n = st_evid1).
    {
      assert (cvmi+1 = S cvmi) by lia.
      find_rewrite.
      eapply span_cvm.
      eassumption.
      econstructor; tauto.
      invc Heqp0.
      eassumption.
    }
    subst.

    assert (n0 = st_evid) by lia.
    
    repeat do_anno_redo.
    
    do_suffix blah.
    do_suffix blah'.
    destruct_conjs; subst.
    repeat do_restl.

    assert (ev = Term_Defs.split cvmi st_pl0 \/
            (In ev blah') \/
            (In ev blah) \/
            ev = join st_evid st_pl0).
    {
            apply in_app_or in H1.
      door.
      +
        
        apply in_app_or in H0.
        door.
        ++
          apply in_app_or in H0.
          door.
          +++
            invc H0; try eauto; try solve_by_inversion.
          +++
            eauto.
        ++
          eauto.
      +
        invc H0; try eauto; try solve_by_inversion.
    }
    door.
    subst.
    apply evtsbseqsplit.
    tauto.

    door.
    ff.

    apply evtsbseql.
    simpl.
    assert (S cvmi = cvmi + 1) by lia.
    rewrite <- H3 in *.
    subst.
    eapply IHt1.
    eassumption.
    eapply restl.
    assert (Term_Defs.split cvmi st_pl0 :: blah' = 
    [Term_Defs.split cvmi st_pl0] ++ blah'). 
    {
      intuition.
    }
    repeat find_rewrite.
    eassumption.
    eassumption.


    door.

    apply evtsbseqr.
    simpl.

    eapply IHt2.
    eassumption.
    eapply restl.
    eassumption.
    eassumption.

    subst.

    apply evtsbseqjoin.
    simpl.
    lia.

    +
          assert (n = st_evid1).
    {
      assert (cvmi+1 = S cvmi) by lia.
      find_rewrite.
      eapply span_cvm.
      eassumption.
      econstructor; tauto.
      invc Heqp0.
      eassumption.
    }
    subst.

    assert (n0 = st_evid) by lia.
    
    repeat do_anno_redo.
    
    do_suffix blah.
    do_suffix blah'.
    destruct_conjs; subst.
    repeat do_restl.

    assert (ev = Term_Defs.split cvmi st_pl0 \/
            (In ev blah') \/
            (In ev blah) \/
            ev = join st_evid st_pl0).
    {
            apply in_app_or in H1.
      door.
      +
        
        apply in_app_or in H0.
        door.
        ++
          apply in_app_or in H0.
          door.
          +++
            invc H0; try eauto; try solve_by_inversion.
          +++
            eauto.
        ++
          eauto.
      +
        invc H0; try eauto; try solve_by_inversion.
    }
    door.
    subst.
    apply evtsbseqsplit.
    tauto.

    door.
    ff.

    apply evtsbseql.
    simpl.
    assert (S cvmi = cvmi + 1) by lia.
    rewrite <- H3 in *.
    subst.
    eapply IHt1.
    eassumption.
    eapply restl.
    assert (Term_Defs.split cvmi st_pl0 :: blah' = 
    [Term_Defs.split cvmi st_pl0] ++ blah'). 
    {
      intuition.
    }
    repeat find_rewrite.
    eassumption.
    eassumption.


    door.

    apply evtsbseqr.
    simpl.

    eapply IHt2.
    eassumption.
    eapply restl.
    eassumption.
    eassumption.

    subst.

    apply evtsbseqjoin.
    simpl.
    lia.


  - (* abpar case *)

    wrap_ccp_anno;
    Auto.ff;
    wrap_ccp_anno;
    Auto.ff.

    +

    assert (n = st_evid).
    {
      assert (cvmi+1 = S cvmi) by lia.
      find_rewrite.
      invc Heqp0.
      
      eapply span_cvm; eauto.
      
      econstructor; tauto.
    }
    subst.

    assert (n0 = st_evid + event_id_span (copland_compile t2)) by lia.
    
    subst. clear H6.
    
    
    
    do_suffix blah.

    destruct_conjs; subst.
    repeat do_restl.

    assert (ev = Term_Defs.split cvmi p \/
            In ev ([cvm_thread_start 0 p (copland_compile t2) e] ++
                   blah ++ [cvm_thread_end 0]) \/
            ev = join (st_evid + event_id_span (copland_compile t2)) p).
    {
      apply in_app_or in H1.
      door.
      +
      assert(
           (([Term_Defs.split cvmi p;
            cvm_thread_start 0 p (copland_compile t2) e] ++ blah) ++
                                                                  [cvm_thread_end 0]) =
            ([Term_Defs.split cvmi p] ++ 
              ([(cvm_thread_start 0 p (copland_compile t2) e)] ++ blah ++
                                                               [cvm_thread_end 0]))).
      {
        simpl.
        tauto.
      }
      rewrite H1 in H0.

        apply in_app_or in H0.
        door.
      ++
        invc H0; try eauto; try solve_by_inversion.
      ++
        eauto.

      + invc H0; try eauto; try solve_by_inversion.
    }


    door.
    subst.

    apply evtsbparsplit.
    auto.
    door.
    rewrite thread_bookend_peel in H0.

    assert (In ev [Term_Defs.split cvmi p] \/ 
            In ev (cvm_events_core (copland_compile t2) p e) \/ 
            In ev blah \/ 
            In ev [join (st_evid + event_id_span (copland_compile t2)) p]).
    {

    invc H1.
    left; eauto.
    auto with *.

    assert (In ev ([cvm_thread_start 0 p (copland_compile t2) e] ++ blah ++ [cvm_thread_end 0]) \/ 
            In ev [join (st_evid + event_id_span (copland_compile t2)) p]).
            {
              auto with *.
            }

            invc H1.

            assert (In ev (cvm_events_core (copland_compile t2) p e) \/ 
                    In ev blah).
                    {
                      eapply cvm_thread_in_ev; eassumption.
                    }

                    door.
                    eauto.
                    eauto.
                    eauto.
    }

    door.

    invc H3; try solve_by_inversion.

    door.

    eapply evtsbparr.

    pose (build_cvm_external (copland_compile t2) (evc bits e) p st_evid ac).

    assert (exists b et, cvm_evidence_core (copland_compile t2) p (evc bits e) = 
    evc b et).
    {
      eapply cvm_evidence_exists_remote.
    }
    destruct_conjs.
    rewrite H6 in *.







    eapply IHt2.
    eassumption.
    simpl.
    econstructor.
    eassumption.
    apply H3.

    door.

    apply evtsbparl.
    eapply IHt1.

    eassumption.
    simpl.
    assert (S cvmi =  cvmi + 1) by lia.
    rewrite H4.
    eapply restl.
    eassumption.
    eassumption.

    invc H3; try solve_by_inversion.

    eapply evtsbparjoin.
    simpl.
    lia.



    eauto.

    (*

    eapply evtsbparsplit.
    simpl; eauto.
    solve_by_inversion.

    admit. (* TODO: axiom? *)
    eauto.

    *)


    subst.

    apply evtsbparjoin.
    simpl.
    lia.


    +
      assert (n = st_evid).
    {
      assert (cvmi+1 = S cvmi) by lia.
      find_rewrite.
      invc Heqp0.
      
      eapply span_cvm; eauto.
      econstructor; tauto.
    }
    subst.

    assert (n0 = st_evid + event_id_span (copland_compile t2)) by lia.
    
    subst. clear H6.
    
    
    
    do_suffix blah.

    destruct_conjs; subst.
    repeat do_restl.


    assert (ev = Term_Defs.split cvmi p \/
            In ev ([cvm_thread_start 0 p (lseqc (aspc CLEAR) (copland_compile t2)) e] ++ blah ++
                   [cvm_thread_end 0]) \/
            ev = join (st_evid + event_id_span (copland_compile t2)) p
           ).
    {
      apply in_app_or in H1.
      door.
      +
      assert(
           (([Term_Defs.split cvmi p;
            cvm_thread_start 0 p (lseqc (aspc CLEAR) (copland_compile t2)) e] ++ blah) ++
                                                                  [cvm_thread_end 0]) =
            ([Term_Defs.split cvmi p] ++ 
              ([(cvm_thread_start 0 p (lseqc (aspc CLEAR) (copland_compile t2)) e)] ++ blah ++
                                                               [cvm_thread_end 0]))).
      {
        simpl.
        tauto.
      }
      rewrite H1 in H0.

        apply in_app_or in H0.
        door.
      ++
        invc H0; try eauto; try solve_by_inversion.
      ++
        eauto.

      + invc H0; try eauto; try solve_by_inversion.
    }
  
    door.
    subst.

    apply evtsbparsplit.
    auto.
    door.
    rewrite thread_bookend_peel in H0; eauto.


    assert (In ev [Term_Defs.split cvmi p] \/ 
    In ev (cvm_events_core (copland_compile t2) p mt) \/ 
    In ev blah \/ 
    In ev [join (st_evid + event_id_span (copland_compile t2)) p]).
{

invc H1.
left; eauto.
auto with *.



Unset Printing Notations.

assert (In ev ([cvm_thread_start 0 p (copland_compile t2) mt] ++ blah ++ [cvm_thread_end 0]) \/ 
        In ev [join (st_evid + event_id_span (copland_compile t2)) p]).
        {
          assert (
            (cvm_thread_start 0 p (lseqc (aspc CLEAR) (copland_compile t2)) e) = 
            (cvm_thread_start 0 p (copland_compile t2)) mt).
            {
              eapply cvm_thread_start_clear.
            }
            rewrite H1 in *; clear H1.

            auto with *.

        }

        invc H1.

        assert (In ev (cvm_events_core (copland_compile t2) p mt) \/ 
                In ev blah).
                {
                  eapply cvm_thread_in_ev; eassumption.
                }

                door.
                eauto.
                eauto.
                eauto.

}

door.

invc H3; try solve_by_inversion.

door.

eapply evtsbparr.

pose (build_cvm_external (copland_compile t2) (evc bits mt) p st_evid ac).

assert (exists b et, cvm_evidence_core (copland_compile t2) p (evc bits mt) = 
evc b et).
{
  eapply cvm_evidence_exists_remote.
}
destruct_conjs.
rewrite H6 in *.






eapply IHt2.
eassumption.
econstructor.
simpl.
eassumption.

apply H3.


door.

apply evtsbparl.
eapply IHt1.

eassumption.
simpl.
assert (S cvmi =  cvmi + 1) by lia.
rewrite H4.
eapply restl.
eassumption.
eassumption.

invc H3; try solve_by_inversion.

eapply evtsbparjoin.
simpl.
lia.



eauto.

(*

eapply evtsbparsplit.
simpl; eauto.
solve_by_inversion.

admit. (* TODO: axiom? *)
eauto.

*)



    subst.

    apply evtsbparjoin.
    simpl.
    lia.

    +
      assert (n = st_evid).
    {
      assert (cvmi+1 = S cvmi) by lia.
      find_rewrite.
      invc Heqp0.
      
      eapply span_cvm; eauto.
      econstructor; tauto.
    }
    subst.

    assert (n0 = st_evid + event_id_span (copland_compile t2)) by lia.
    
    subst. clear H6.
    
    
    
    do_suffix blah.

    destruct_conjs; subst.
    repeat do_restl.

    assert (ev = Term_Defs.split cvmi p \/
            In ev ([cvm_thread_start 0 p (copland_compile t2) e] ++
                   blah ++ [cvm_thread_end 0]) \/
            ev = join (st_evid + event_id_span (copland_compile t2)) p).
        {
      apply in_app_or in H1.
      door.
      +
      assert(
           (([Term_Defs.split cvmi p;
            cvm_thread_start 0 p (copland_compile t2) e] ++ blah) ++
                                                                  [cvm_thread_end 0]) =
            ([Term_Defs.split cvmi p] ++ 
              ([(cvm_thread_start 0 p (copland_compile t2) e)] ++ blah ++
                                                               [cvm_thread_end 0]))).
      {
        simpl.
        tauto.
      }
      rewrite H1 in H0.

        apply in_app_or in H0.
        door.
      ++
        invc H0; try eauto; try solve_by_inversion.
      ++
        eauto.

      + invc H0; try eauto; try solve_by_inversion.
    }

    door.
    subst.

    apply evtsbparsplit.
    auto.
    door.
    rewrite thread_bookend_peel in H0.




    assert (In ev [Term_Defs.split cvmi p] \/ 
    In ev (cvm_events_core (copland_compile t2) p e) \/ 
    In ev blah \/ 
    In ev [join (st_evid + event_id_span (copland_compile t2)) p]).
{

invc H1.
left; eauto.
auto with *.

assert (In ev ([cvm_thread_start 0 p (copland_compile t2) e] ++ blah ++ [cvm_thread_end 0]) \/ 
        In ev [join (st_evid + event_id_span (copland_compile t2)) p]).
        {
          auto with *.
        }

        invc H1.

        assert (In ev (cvm_events_core (copland_compile t2) p e) \/ 
                In ev blah).
                {
                  eapply cvm_thread_in_ev; eassumption.
                }

                door.
                eauto.
                eauto.
                eauto.

}

door.

invc H3; try solve_by_inversion.

door.

eapply evtsbparr.



pose (build_cvm_external (copland_compile t2) (evc bits e) p st_evid ac).

assert (exists b et, cvm_evidence_core (copland_compile t2) p (evc bits e) = 
evc b et).
{
  eapply cvm_evidence_exists_remote.
}
destruct_conjs.
rewrite H6 in *.



eapply IHt2.
eassumption.

simpl.
econstructor.
eassumption.

apply H3.


door.

apply evtsbparl.
eapply IHt1.

eassumption.
simpl.
assert (S cvmi =  cvmi + 1) by lia.
rewrite H4.
eapply restl.
eassumption.
eassumption.

invc H3; try solve_by_inversion.

eapply evtsbparjoin.
simpl.
lia.



eauto.

(*

eapply evtsbparsplit.
simpl; eauto.
solve_by_inversion.

admit. (* TODO: axiom? *)
eauto.

*)


    subst.

    apply evtsbparjoin.
    simpl.
    lia.

    +
      assert (n = st_evid).
    {
      assert (cvmi+1 = S cvmi) by lia.
      find_rewrite.
      invc Heqp0.
      
      eapply span_cvm; eauto.
      econstructor; tauto.
    }
    subst.

    assert (n0 = st_evid + event_id_span (copland_compile t2)) by lia.
    
    subst. clear H6.
    
    
    
    do_suffix blah.

    destruct_conjs; subst.
    repeat do_restl.

    assert (ev = Term_Defs.split cvmi p \/
            In ev ([cvm_thread_start 0 p (lseqc (aspc CLEAR) (copland_compile t2)) e] ++ blah ++
                   [cvm_thread_end 0]) \/
            ev = join (st_evid + event_id_span (copland_compile t2)) p
           ).
        {
      apply in_app_or in H1.
      door.
      +
      assert(
           (([Term_Defs.split cvmi p;
            cvm_thread_start 0 p (lseqc (aspc CLEAR) (copland_compile t2)) e] ++ blah) ++
                                                                  [cvm_thread_end 0]) =
            ([Term_Defs.split cvmi p] ++ 
              ([(cvm_thread_start 0 p (lseqc (aspc CLEAR) (copland_compile t2)) e)] ++ blah ++
                                                               [cvm_thread_end 0]))).
      {
        simpl.
        tauto.
      }
      rewrite H1 in H0.

        apply in_app_or in H0.
        door.
      ++
        invc H0; try eauto; try solve_by_inversion.
      ++
        eauto.

      + invc H0; try eauto; try solve_by_inversion.
    }

    door.
    subst.

    apply evtsbparsplit.
    auto.
    door.
    Unset Printing Notations.

    assert (
      (cvm_thread_start 0 p (lseqc (aspc CLEAR) (copland_compile t2)) e) = 
      (cvm_thread_start 0 p (copland_compile t2)) mt).
      {
        eapply cvm_thread_start_clear.
      }
      rewrite H3 in *; clear H1.

    assert (
            In ev (cvm_events_core (copland_compile t2) p mt) \/ 
            In ev blah).
            {

              eapply cvm_thread_in_ev; eassumption.


            }
    door.

    2: {

    apply evtsbparl.

    simpl in *.
    unfold mt_evc in *.
    assert (S cvmi = cvmi + 1) by lia.
    rewrite <- H4 in *.


    eapply IHt1.
    eassumption.
    eapply restl.

    rewrite fufu in Heqp3.



(*
    ff.
    assert ((
      (Term_Defs.split cvmi p :: (cvm_thread_start 0 p <<core>{ (CLR -> (copland_compile t2)) }> e)) :: blah) = 
            [Term_Defs.split cvmi p :: (cvm_thread_start 0 p <<core>{ CLR -> (copland_compile t2) }> e)] ++ blah).
    eassumption.
    (* 
    assert ((Term_Defs.split cvmi p :: cvm_thread_start 0 p <<core>{ CLR -> (copland_compile t2) }> e :: blah) = 
    ([Term_Defs.split cvmi p :: cvm_thread_start 0 p <<core>{ CLR -> (copland_compile t2) }> e] ++ blah)).
    {
      intuition.
    }
    *)
    admit.

    *)
    eassumption.

    eassumption.

    }


    apply evtsbparr.



    pose (build_cvm_external (copland_compile t2) (evc bits mt) p st_evid ac).

assert (exists b et, cvm_evidence_core (copland_compile t2) p (evc bits mt) = 
evc b et).
{
  eapply cvm_evidence_exists_remote.
}
destruct_conjs.
rewrite H6 in *.





    simpl.

    eapply IHt2.
    eassumption.

    econstructor.
    eassumption.

    eauto.

    eauto.


    subst.

    apply evtsbparjoin.
    simpl.
    lia.
Qed.

Lemma cvm_respects_events_disclosure:
  forall t p e i r atp bits bits' p' e' cvm_tr cvmi cvmi' annt ac ac',
    
    annoP_indexed annt t cvmi cvmi' ->
    ~ (events_discloses annt p e i r) ->
    
    term_to_coreP t atp ->
    build_cvmP atp
               (mk_st (evc bits e) [] p cvmi ac)
               (resultC tt)
               (mk_st (evc bits' e') cvm_tr p' cvmi' ac') ->

    ~ (cvm_trace_discloses_to_remote cvm_tr i r).

Proof.
  unfold not in *; intros.
  apply H0.
  invc H3.
  destruct_conjs.
  unfold events_discloses.
  (*exists H4. *) exists x. (* exists H3. exists H5. exists H6. exists H7. *)
  split.
  invc H1.
  eapply cvm_implies_events.
  eassumption.
  eassumption.
  apply H3.
  eassumption.
Qed.

Lemma cvm_respects_term_disclosure:
  forall t p e i r atp bits bits' p' e' cvm_tr cvmi cvmi' annt ac ac',

    annoP_indexed annt t cvmi cvmi' ->

  ~ (term_discloses_to_remote t p e (r,i) = true) ->
  
  term_to_coreP t atp ->
  build_cvmP atp
             (mk_st (evc bits e) [] p cvmi ac)
             (resultC tt)
             (mk_st (evc bits' e') cvm_tr p' cvmi' ac') ->

  ~ (cvm_trace_discloses_to_remote cvm_tr r i).
Proof.
  intros.

  eapply cvm_respects_events_disclosure.
  
  eassumption.
  eapply events_respects_term_disclosure.
  invc H.
  econstructor.
  repeat eexists.
  eassumption.
  eassumption.
  eassumption.
  eassumption.
Qed.



Lemma cvm_respects_events_disclosure_aspid_enc:
forall t p e i r atp bits bits' p' e' cvm_tr cvmi cvmi' annt ac ac',
  
  annoP_indexed annt t cvmi cvmi' ->
  ~ (events_discloses_aspid_enc annt p e i r) ->
  
  term_to_coreP t atp ->
  build_cvmP atp
              (mk_st (evc bits e) [] p cvmi ac)
              (resultC tt)
              (mk_st (evc bits' e') cvm_tr p' cvmi' ac') ->

  ~ (cvm_trace_discloses_aspid_to_remote_enc cvm_tr i r).

Proof.
  unfold not in *; intros.
  apply H0.
  invc H3.
  destruct_conjs.
  unfold events_discloses_aspid_enc.
  (*exists H4. *) exists x. (* exists H3. exists H5. exists H6. exists H7. *)
  split.
  eassumption.
  invc H4.
  destruct_conjs.

  invc H1.

  econstructor.
  (* exists H5. exists H4. exists H6. *)
  split; eauto.
  eapply cvm_implies_events; eauto.
Qed.


Lemma cvm_respects_term_disclosure_aspid_enc:
  forall t p e i r atp bits bits' p' e' cvm_tr cvmi cvmi' annt ac ac',

    annoP_indexed annt t cvmi cvmi' ->

  ~ (term_discloses_aspid_to_remote_enc t p e i r) ->
  
  term_to_coreP t atp ->
  build_cvmP atp
             (mk_st (evc bits e) [] p cvmi ac)
             (resultC tt)
             (mk_st (evc bits' e') cvm_tr p' cvmi' ac') ->

  ~ (cvm_trace_discloses_aspid_to_remote_enc cvm_tr i r).
Proof.
  intros.
  
  eapply cvm_respects_events_disclosure_aspid_enc.
  eassumption.
  eapply events_respects_term_disclosure_aspid_enc.
  invc H.
  econstructor.
  repeat eexists.
  eassumption.
  eassumption.
  eassumption.
  eassumption.
Qed.






(** Extra term_disloses* defs (may be deprecated...): 




(*

Lemma term_disc_remote: forall t p e i r p0,
          term_discloses_aspid_to_remote t p e i r ->
          term_discloses_aspid_to_remote <{ @ p [t] }> p0 e i r.
Proof.
  intros.
  invc H.
  destruct_conjs.
  econstructor.
  exists H0.
  split.
  -
    eassumption.
  -
    simpl in *.
    destruct x; try solve_by_inversion.
    destruct a; try solve_by_inversion.
    assert (a = i).
    {
      assert (eqb a i = true).
      {
        repeat rewrite Bool.andb_true_r in H.
        auto.
      }
      eapply eqb_eq_aspid; eauto.
    }
    
    subst.
    find_rewrite.
    rewrite Bool.orb_true_r.
    auto.
Qed.
*)


(*
Lemma term_disc_lseq_l: forall t1 t2 p e i r,
          term_discloses_aspid_to_remote t1 p e i r ->
          term_discloses_aspid_to_remote <{ t1 -> t2 }> p e i r.
Proof.
  intros.
  invc H.
  destruct_conjs.
  econstructor.
  exists H0.
  split.
  -
    eassumption.
  -
    simpl in *.
    destruct x; try solve_by_inversion.
    destruct a; try solve_by_inversion.
    assert (a = i).
    {
      assert (eqb a i = true).
      {
        repeat rewrite Bool.andb_true_r in H.
        auto.
      }
      eapply eqb_eq_aspid; eauto.
    }
    
    subst.
    find_rewrite.
    rewrite Bool.orb_true_l.
    auto.
Qed.
*)


(*
Lemma term_disc_lseq_r: forall t1 t2 p e i r,
          term_discloses_aspid_to_remote t2 p (eval t1 p e) i r ->
          term_discloses_aspid_to_remote <{ t1 -> t2 }> p e i r.
Proof.
  intros.
  invc H.
  destruct_conjs.
  econstructor.
  exists H0.
  split.
  -
    eassumption.
  -
    simpl in *.
    destruct x; try solve_by_inversion.
    destruct a; try solve_by_inversion.
    assert (a = i).
    {
      assert (eqb a i = true).
      {
        repeat rewrite Bool.andb_true_r in H.
        auto.
      }
      eapply eqb_eq_aspid; eauto.
    }
    
    subst.
    find_rewrite.
    rewrite Bool.orb_true_r.
    auto.
Qed.
*)


(*

Lemma term_disc_bseq_l: forall t1 t2 p e i r s,
          term_discloses_aspid_to_remote t1 p (splitEv_T_l s e) i r ->
          term_discloses_aspid_to_remote (bseq s t1 t2) p e i r.
Proof.
  intros.
  invc H.
  destruct_conjs.
  econstructor.
  exists H0.
  split.
  -
    eassumption.
  -
    simpl in *.
    destruct x; try solve_by_inversion.
    destruct a; try solve_by_inversion.
    assert (a = i).
    {
      assert (eqb a i = true).
      {
        repeat rewrite Bool.andb_true_r in H.
        auto.
      }
      eapply eqb_eq_aspid; eauto.
    }
    
    subst.
    destruct s.
    destruct s;
      
      simpl in *;
      rewrite H2;
      
      rewrite Bool.orb_true_l;
      auto.
Qed.
*)

(*
Lemma term_disc_bseq_r: forall t1 t2 p e i r s,
          term_discloses_aspid_to_remote t2 p (splitEv_T_r s e) i r ->
          term_discloses_aspid_to_remote (bseq s t1 t2) p e i r.
Proof.
  intros.
  invc H.
  destruct_conjs.
  econstructor.
  exists H0.
  split.
  -
    eassumption.
  -
    simpl in *.
    destruct x; try solve_by_inversion.
    destruct a; try solve_by_inversion.
    assert (a = i).
    {
      assert (eqb a i = true).
      {
        repeat rewrite Bool.andb_true_r in H.
        auto.
      }
      eapply eqb_eq_aspid; eauto.
    }
    
    subst.
    destruct s;
      destruct s;
      destruct s0;

      simpl in *;
      rewrite H2;
      
      rewrite Bool.orb_true_r;
      auto.
Qed.
*)

(*
Lemma term_disc_bpar_l: forall t1 t2 p e i r s,
          term_discloses_aspid_to_remote t1 p (splitEv_T_l s e) i r ->
          term_discloses_aspid_to_remote (bpar s t1 t2) p e i r.
Proof.
  intros.
  invc H.
  destruct_conjs.
  econstructor.
  exists H0.
  split.
  -
    eassumption.
  -
    simpl in *.
    destruct x; try solve_by_inversion.
    destruct a; try solve_by_inversion.
    assert (a = i).
    {
      assert (eqb a i = true).
      {
        repeat rewrite Bool.andb_true_r in H.
        auto.
      }
      eapply eqb_eq_aspid; eauto.
    }
    
    subst.
    destruct s;
      destruct s;
      destruct s0;

      simpl in *;
      rewrite H2;
      
      rewrite Bool.orb_true_l;
      auto.
Qed.
*)

(*
Lemma term_disc_bpar_r: forall t1 t2 p e i r s,
          term_discloses_aspid_to_remote t2 p (splitEv_T_r s e) i r ->
          term_discloses_aspid_to_remote (bpar s t1 t2) p e i r.
Proof.
  intros.
  invc H.
  destruct_conjs.
  econstructor.
  exists H0.
  split.
  -
    eassumption.
  -
    simpl in *.
    destruct x; try solve_by_inversion.
    destruct a; try solve_by_inversion.
    assert (a = i).
    {
      assert (eqb a i = true).
      {
        repeat rewrite Bool.andb_true_r in H.
        auto.
      }
      eapply eqb_eq_aspid; eauto.
    }
    
    subst.
    destruct s;
      destruct s;
      destruct s0;

      simpl in *;
      rewrite H2;
      
      rewrite Bool.orb_true_r;
      auto.
Qed.
*)



















*)
              
  
                                               
