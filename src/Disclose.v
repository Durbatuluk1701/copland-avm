(*
Experiments in stating "disclosure" properties of the CVM.

Author:  Adam Petz, ampetz@ku.edu
*)

Require Import Term_Defs Anno_Term_Defs Term LTS Cvm_Impl Cvm_St Trace Main ConcreteEvidence.

Require Import CvmSemantics Appraisal_Evidence Eqb_Evidence Auto ID_Type EqClass Helpers_CvmSemantics (* Disclose_Gen *) External_Facts Axioms_Io.

Require Import StructTactics.

Require Import ErrorStMonad_Coq.

Require Import Coq.Program.Tactics PeanoNat Lia.

Require Import List.
Import ListNotations.

(*
Set Nested Proofs Allowed.
*)

Fixpoint evsubt_bool `{EqClass Evidence} (e e' : Evidence) : bool :=
  match (eqb e e') with
  | true => true
  | false =>
    match e' with
    | uu _ _ _ et' => evsubt_bool e et'
    | ss e1 e2 => evsubt_bool e e1 || evsubt_bool e e2 
    | _ => false
    end
  end.

Definition get_targ_plc (ps:ASP_PARAMS) : Plc := 
  match ps with 
  | asp_paramsC _ _ tp _ => tp 
  end.

Definition get_asp_id (ps:ASP_PARAMS) : ASP_ID := 
    match ps with 
    | asp_paramsC i _ _ _ => i 
    end.

(** Evidence Type "subterm" relation modulo encryption. 
    The relation (EvSubTAspEnc e' i p) states that Evidence Type e' 
      makes visible to place p evidence generated by ASP i (modulo encryption).
    Stated another way:  Evidence from ASP i can be viewed "in the clear" by 
      place p with access to e' (modulo decryption by place p).

*)

Inductive EvSubTAspEnc: Evidence -> ASP_ID -> Plc -> Prop :=
| uuSubT_asp_noenc: forall e' p q ps i fwd,
    get_asp_id ps = i -> 
    fwd <> ENCR (* /\ fwd <> COMP *) -> 
    (* TODO: include COMP here for appraisal/cert asps hiding evidence? *)
    EvSubTAspEnc (uu p fwd ps e') i q
| uuSubT_asp_noenc_sub: forall e' p q fwd ps i,
    EvSubTAspEnc e' i q -> 
    fwd <> ENCR -> 
    EvSubTAspEnc (uu p fwd ps e') i q
| uuSubT_asp_enc: forall e' p q ps i,
    get_targ_plc ps = q -> 
    get_asp_id ps = i -> 
    EvSubTAspEnc (uu p ENCR ps e') i q
| uuSubT_asp_enc_sub: forall e' p q ps i,
    EvSubTAspEnc e' i q -> 
    get_targ_plc ps = q -> 
    EvSubTAspEnc (uu p ENCR ps e') i q
| ssSublT: forall e' e'' q i,
    EvSubTAspEnc e' i q ->
    EvSubTAspEnc (ss e' e'') i q
| ssSubrT: forall e' e'' q i,
    EvSubTAspEnc e'' i q ->
    EvSubTAspEnc (ss e' e'') i q.
#[export] Hint Constructors EvSubTAspEnc : core.


Definition evsubt_asp_enc_bool (e:Evidence) (i:ASP_ID) (q:Plc): bool.
Admitted.

Lemma evsubt_asp_enc_prop_bool: forall e i q,
    EvSubTAspEnc e i q -> evsubt_asp_enc_bool e i q = true.
Proof.
Admitted.

Lemma evsubt_asp_enc_bool_prop: forall e i q,
  evsubt_asp_enc_bool e i q = true -> EvSubTAspEnc e i q.
Proof.
Admitted.

Lemma evsubt_asp_enc_bool_prop_iff: forall e i q,
    EvSubTAspEnc e i q <-> evsubt_asp_enc_bool e i q = true.
Proof.
  intros; split.
  apply evsubt_asp_enc_prop_bool.
  apply evsubt_asp_enc_bool_prop.
Qed.

Lemma evsubt_prop_bool : forall e e',
    EvSubT e e' -> evsubt_bool e e' = true.
Proof.
  intros.
  generalizeEverythingElse e'.
  induction e'; intuition; invc H; repeat ff; eauto;
  try match goal with
  | H : eqb_evidence ?x ?x = false |- _ => 
      destruct (eqb_eq_evidence x x); intuition; congruence
  end;
  eapply Bool.orb_true_iff; eauto.
Qed.

Lemma evsubt_bool_prop : forall e e',
    evsubt_bool e e' = true -> EvSubT e e'.
Proof.
  intros.
  generalizeEverythingElse e'.
  induction e'; intros.
  - destruct e; repeat ff;
    rewrite eqb_eq_evidence in Heqb; congruence.
  - destruct e; repeat ff;
    rewrite eqb_eq_evidence in Heqb; try congruence;
    find_injection; ff.
  - destruct e; repeat ff;
    rewrite eqb_eq_evidence in Heqb; try congruence;
    find_injection; ff.
  - destruct e; repeat ff;
    try rewrite eqb_eq_evidence in Heqb; try congruence;
    repeat rewrite Bool.orb_true_iff in *; 
    intuition;
    find_injection; ff.
Qed.

Lemma evsubt_bool_prop_iff : forall e e',
    EvSubT e e' <-> evsubt_bool e e' = true.
Proof.
  intros; split.
  apply evsubt_prop_bool.
  apply evsubt_bool_prop.
Qed.


(* A relation specifying events (Ev) that disclose evidence to other places.
   Technically, we are considering "Evidence Types" (Evidence), but the correspondence of 
   those types to concrete binary evidence values is maintained by the CVM.
 
  Example:  
  discloses_to_remote ev (q,et) says that event ev discloses evidence of type et to place q.

*)

Inductive discloses_to_remote: Ev -> (Plc*Evidence) -> Prop :=
| at_disclose: forall i p q t e,
    discloses_to_remote (req i p q t e) (q,e).         

Definition discloses_aspid_to_remote_enc (q:Plc) (i:ASP_ID) : Prop :=
      forall e reqid p t,
        EvSubTAspEnc e i q ->  (* TODO: check ok to use q here and not freshly quantified var... *)
        (discloses_to_remote (req reqid p q t e) (q, e)).


Definition splitEv_mt (sp:SP) (e:Evidence) : Evidence :=
  match sp with
  | ALL => e
  | NONE => mt
  end.

Fixpoint term_discloses_to_remote (t:Term) (p:Plc) (e:Evidence) (r:(Plc*Evidence)) : bool :=
  match t with
  | att q t' => ((eqb_plc q (fst r)) && (eqb_evidence (snd r) e))  ||      (* (evsubt_bool (snd r) e) *)
                ((eqb_plc p (fst r)) && (eqb_evidence (snd r) (eval t' q e))) ||
               (term_discloses_to_remote t' q e r)
  | lseq t1 t2 => (term_discloses_to_remote t1 p e r) ||
                 (term_discloses_to_remote t2 p (eval t1 p e) r)
  | bseq (sp1,sp2) t1 t2 => (term_discloses_to_remote t1 p (splitEv_mt sp1 e) r) ||
                           (term_discloses_to_remote t2 p (splitEv_mt sp2 e) r)
  | bpar (sp1,sp2) t1 t2 => (term_discloses_to_remote t1 p (splitEv_mt sp1 e) r) ||
                           (term_discloses_to_remote t2 p (splitEv_mt sp2 e) r)
  | _ => false
  end.

Definition term_discloses_aspid_to_remote_enc (t:Term) (p:Plc) (e:Evidence) (i:ASP_ID) (r:Plc) : Prop :=
      exists e',
        EvSubTAspEnc e' i r /\
        ((term_discloses_to_remote t p e (r,e')) = true).

Lemma term_discloses_aspid_to_remote_enc_prop_bool_iff : 
  forall t p e i r, 
    term_discloses_aspid_to_remote_enc t p e i r <-> 
    term_discloses_aspid_to_remote_enc_bool t p e i r = true.
Proof.
Admitted.


Definition cvm_trace_discloses_to_remote (tr:list Ev) (r:Plc) (e:Evidence) : Prop :=
  exists ev,
    (In ev tr) /\

    (
      (exists reqi reqp reqt, 
        ev = (req reqi reqp r reqt e)) \/ 
      (exists rpyi rpyp, 
        ev = (rpy rpyi r rpyp e))
    ).


 Definition cvm_trace_discloses_aspid_to_remote_enc (tr:list Ev) (i:ASP_ID) (r:Plc) : Prop :=
  exists e,
     evsubt_asp_enc_bool e i r = true /\
     cvm_trace_discloses_to_remote tr r e.

Definition events_discloses (annt:AnnoTerm) (p:Plc) (e:Evidence) (r:Plc) (e':Evidence): Prop :=
    exists ev,
      (
        (* annoP annt t /\  *)
        events annt p e ev /\
        (
          (exists reqi reqp reqt, 
            ev = (req reqi reqp r reqt e')) \/ 
          (exists rpyi rpyp, 
            ev = (rpy rpyi r rpyp e'))
        )
      ).

Definition events_discloses_aspid_enc (annt:AnnoTerm) (p:Plc) (e:Evidence) (i:ASP_ID) (r:Plc): Prop :=
  exists reqe,
     evsubt_asp_enc_bool reqe i r = true /\
     events_discloses annt p e r reqe.

Open Scope cop_ent_scope.

Lemma term_disc_remote_enc : forall t p e i r p0,
          term_discloses_aspid_to_remote_enc t p e i r ->
          term_discloses_aspid_to_remote_enc <{ @ p [t] }> p0 e i r.
Proof.
  intros.
  invc H.
  destruct_conjs.
  econstructor.
  split.
  - 
    eassumption.
  -
    ff.
    find_rewrite.
    apply Bool.orb_true_r.
Qed.

Lemma term_disc_lseq_l_enc : forall t1 t2 p e i r,
          term_discloses_aspid_to_remote_enc t1 p e i r ->
          term_discloses_aspid_to_remote_enc <{ t1 -> t2 }> p e i r.
Proof.
  intros.
  invc H.
  destruct_conjs.
  econstructor.
  split.
  - 
    eassumption.
  -
    ff.
    find_rewrite.
    apply Bool.orb_true_l.
Qed.

Lemma term_disc_lseq_r_enc : forall t1 t2 p e i r,
          term_discloses_aspid_to_remote_enc t2 p (eval t1 p e) i r ->
          term_discloses_aspid_to_remote_enc <{ t1 -> t2 }> p e i r.
Proof.
  intros.
  invc H.
  destruct_conjs.
  econstructor.
  split.
  - 
    eassumption.
  -
    ff.
    find_rewrite.
    apply Bool.orb_true_r.
Qed.

Close Scope cop_ent_scope.

Lemma term_disc_bseq_l_enc : forall t1 t2 p e i r s,
          term_discloses_aspid_to_remote_enc t1 p (splitEv_T_l s e) i r ->
          term_discloses_aspid_to_remote_enc (bseq s t1 t2) p e i r.
Proof.
  intros.
  invc H.
  destruct_conjs.
  econstructor.
  split.
  - 
    eassumption.
  -
    ff.
    subst.
    destruct s0;
    destruct s1;
      
      simpl in *;
      (* rewrite H0; *)
      find_rewrite;
      
      rewrite Bool.orb_true_l;
      auto.
Qed.

Lemma term_disc_bseq_r_enc : forall t1 t2 p e i r s,
          term_discloses_aspid_to_remote_enc t2 p (splitEv_T_r s e) i r ->
          term_discloses_aspid_to_remote_enc (bseq s t1 t2) p e i r.
Proof.
  intros.
  invc H.
  destruct_conjs.
  econstructor.
  split.
  - 
    eassumption.
  -
    ff.
    subst.
    destruct s0;
    destruct s1;
      
      simpl in *;
      find_rewrite; 
      
      rewrite Bool.orb_true_r;
      auto.
Qed.

Lemma term_disc_bpar_l_enc : forall t1 t2 p e i r s,
          term_discloses_aspid_to_remote_enc t1 p (splitEv_T_l s e) i r ->
          term_discloses_aspid_to_remote_enc (bpar s t1 t2) p e i r.
Proof.
  intros.
  invc H.
  destruct_conjs.
  econstructor.
  split.
  - 
    eassumption.
  -
    ff.
    subst.
    destruct s0;
    destruct s1;
      
      simpl in *;
      find_rewrite;
      
      rewrite Bool.orb_true_l;
      auto.
Qed.


Lemma term_disc_bpar_r_enc : forall t1 t2 p e i r s,
          term_discloses_aspid_to_remote_enc t2 p (splitEv_T_r s e) i r ->
          term_discloses_aspid_to_remote_enc (bpar s t1 t2) p e i r.
Proof.
  intros.
  invc H.
  destruct_conjs.
  econstructor.
  split.
  - 
    eassumption.
  -
    ff.
    subst.
    destruct s0;
    destruct s1;
      
      simpl in *;
      find_rewrite;
      
      rewrite Bool.orb_true_r;
      auto.
Qed.

Lemma term_discloses_respects_events : forall annt t p e r H2,
      annoP annt t -> 
      events_discloses annt p e r H2 ->
      term_discloses_to_remote t p e (r, H2) = true.
Proof.
  intros.
  unfold not in * ; intros.
  (*
  unfold events_discloses_aspid in *.
  (*
  assert (exists annt cvmi, annoP_indexed annt t 0 cvmi). admit.
  destruct_conjs.
  specialize (H0 H1 H2 H3). *)
  destruct_conjs.
  subst.
  *)

  generalizeEverythingElse t.
  induction t; intros.

  - (* asp case *)
    invc H.
    destruct_conjs.
    invc H0.
    destruct_conjs.
    door;
    repeat ff.
  - (* at case *)
    invc H0.
    destruct_conjs.

    door.
    + (* req case *)

    ff.
    invc H.
    destruct_conjs.

    invc H5; try solve_by_inversion.
    ff.
    invc H0.
    ++
    assert (eqb r r = true).
    {
      eapply eqb_eq_plc; eauto.
    }
      assert (eqb_evidence H2 H2 = true).
    {
      eapply eqb_eq_evidence; eauto.
    }

    repeat (simpl in *; find_rewrite); eauto.
    ++
      assert (term_discloses_to_remote t p e (r, H2) = true).
      {
        eapply IHt with (p:=p).
        econstructor.
        repeat eexists.
        eassumption.
        econstructor.
        repeat eexists.
        eassumption.
        left.
        eauto.
      }
      find_rewrite.
      rewrite Bool.orb_true_r.
      auto.

    + (* rpy case *)

    ff.
    match goal with
    | H : annoP _ _ |- _ => invc H
    end.
    destruct_conjs.
    match goal with
    | H : anno _ _ = _ |- _ => invc H
    end.
    ff.
    match goal with
    | H : events _ _ _ _ |- _ => invc H
    end.
    ++ 

    assert (term_discloses_to_remote t p e (r, H2) = true).
    {
      eapply IHt with (p:=p).
      econstructor.
      repeat eexists.
      eassumption.
      econstructor.
      repeat eexists.
      eassumption.
      right.
      eauto.
    }
    find_rewrite.
    rewrite Bool.orb_true_r.
    auto.

    ++

    assert (eqb r r = true).
    {
      eapply eqb_eq_plc; eauto.
    }
    assert (eqb_evidence (aeval a H3 e) (eval t H3 e) = true).
    {
      erewrite eval_aeval.
      rewrite Heqp1.
      simpl.
      eapply eqb_eq_evidence; eauto.
    }

    repeat (simpl in *; find_rewrite); eauto.
    rewrite Bool.orb_true_r; eauto.

  - (* lseq case *)

    match goal with
    | H : annoP _ _ |- _ => invc H
    end.
    destruct_conjs.

    match goal with
    | H : anno _ _ = _ |- _ => invc H
    end.

    repeat break_let.
    ff.
    match goal with
    | H : events_discloses _ _ _ _ _ |- _ => invc H
    end.

    destruct_conjs.

    door.
    + (* req case *)

    subst.
    match goal with
    | H : events _ _ _ _ |- _ => invc H
    end.
    ++

      assert (term_discloses_to_remote t1 p e (r, H2) = true).
      {

      (* left subterm *)
      eapply IHt1 with (p:=p). (* with (H7 := (uu p0 f (asp_paramsC a0 l p1 t) e0)). *)
      econstructor.
      repeat eexists.
      eassumption.

      econstructor.
      repeat eexists.
      eassumption.
      left; eauto.
      }
      find_rewrite.
      simpl.
      tauto.
      
    ++ (* right subterm *)

      assert (term_discloses_to_remote t2 p (eval t1 p e) (r, H2) = true).
      {
         assert (aeval a p e = eval t1 p e).
      {
        erewrite eval_aeval.
        rewrite Heqp0.
        simpl.
        tauto.
      }
      find_reverse_rewrite.
      eapply IHt2 with (p:=p). (* with (H7 := (uu p0 f (asp_paramsC a0 l p1 t) e0)). *)
      econstructor.
      repeat eexists.
      eassumption.

      econstructor.
      repeat eexists.
      eassumption.
      left; eauto.
      }
      find_rewrite.

      rewrite Bool.orb_true_r.
      tauto.

   + (* rpy case *)

    subst.
    match goal with
    | H : events _ _ _ _ |- _ => invc H
    end.
    ++

      assert (term_discloses_to_remote t1 p e (r, H2) = true).
      {

      (* left subterm *)
      eapply IHt1 with (p:=p). (* with (H7 := (uu p0 f (asp_paramsC a0 l p1 t) e0)). *)
      econstructor.
      repeat eexists.
      eassumption.

      econstructor.
      repeat eexists.
      eassumption.
      right; eauto.
      }
      find_rewrite.
      simpl.
      tauto.
      
    ++ (* right subterm *)

      assert (term_discloses_to_remote t2 p (eval t1 p e) (r, H2) = true).
      {
         assert (aeval a p e = eval t1 p e).
      {
        erewrite eval_aeval.
        rewrite Heqp0.
        simpl.
        tauto.
      }
      find_reverse_rewrite.
      eapply IHt2 with (p:=p). (* with (H7 := (uu p0 f (asp_paramsC a0 l p1 t) e0)). *)
      econstructor.
      repeat eexists.
      eassumption.

      econstructor.
      repeat eexists.
      eassumption.
      right; eauto.
      }
      find_rewrite.

      rewrite Bool.orb_true_r.
      tauto.

  - (* bseq case *)

    match goal with
    | H : annoP _ _ |- _ => invc H
    end.
    destruct_conjs.

    match goal with
    | H : anno _ _ = _ |- _ => invc H
    end.
    repeat break_let.
    ff.

    match goal with
    | H : events_discloses _ _ _ _ _ |- _ => invc H
    end.
    destruct_conjs.
    subst.
    destruct s0; destruct s1; ff.

    +

    door; subst. 

    ++ (* req case *)
      
      match goal with
      | H : events _ _ _ _ |- _ => invc H
      end.
      +++

      assert (term_discloses_to_remote t1 p e (r, H2) = true).
      {

      (* left subterm *)
      eapply IHt1 with (p:=p). (* with (H7 := (uu p0 f (asp_paramsC a0 l p1 t) e0)). *)
      econstructor.
      repeat eexists.
      eassumption.
      ff.
      econstructor.
      repeat eexists.
      eassumption.
      eauto.
      }
      find_rewrite.
      simpl.
      tauto.
      +++
          assert (term_discloses_to_remote t2 p e (r, H2) = true).
      {

      (* left subterm *)
      eapply IHt2 with (p:=p). (* with (H7 := (uu p0 f (asp_paramsC a0 l p1 t) e0)). *)
      econstructor.
      repeat eexists.
      eassumption.
      ff.
      econstructor.
      repeat eexists.
      eassumption.
      eauto.
      }
      find_rewrite.
         rewrite Bool.orb_true_r.
         tauto.

    ++ (* rpy case *)


    match goal with
    | H : events _ _ _ _ |- _ => invc H
    end.
    +++
  

    assert (term_discloses_to_remote t1 p e (r, H2) = true).
    {

    (* left subterm *)
    eapply IHt1 with (p:=p). (* with (H7 := (uu p0 f (asp_paramsC a0 l p1 t) e0)). *)
    econstructor.
    repeat eexists.
    eassumption.
    ff.
    econstructor.
    repeat eexists.
    eassumption.
    eauto.
    }
    find_rewrite.
    simpl.
    tauto.
    +++
        assert (term_discloses_to_remote t2 p e (r, H2) = true).
    {

    (* left subterm *)
    eapply IHt2 with (p:=p). (* with (H7 := (uu p0 f (asp_paramsC a0 l p1 t) e0)). *)
    econstructor.
    repeat eexists.
    eassumption.
    ff.
    econstructor.
    repeat eexists.
    eassumption.
    eauto.
    }
    find_rewrite.
       rewrite Bool.orb_true_r.
       tauto.



    +

       door; subst. 
   
       ++ (* req case *)
         
         match goal with
         | H : events _ _ _ _ |- _ => invc H
         end.
         +++
       
   
         assert (term_discloses_to_remote t1 p e (r, H2) = true).
         {
   
         (* left subterm *)
         eapply IHt1 with (p:=p). (* with (H7 := (uu p0 f (asp_paramsC a0 l p1 t) e0)). *)
         econstructor.
         repeat eexists.
         eassumption.
         ff.
         econstructor.
         repeat eexists.
         eassumption.
         eauto.
         }
         find_rewrite.
         simpl.
         tauto.
         +++
             assert (term_discloses_to_remote t2 p mt (r, H2) = true).
         {
   
         (* left subterm *)
         eapply IHt2 with (p:=p). (* with (H7 := (uu p0 f (asp_paramsC a0 l p1 t) e0)). *)
         econstructor.
         repeat eexists.
         eassumption.
         ff.
         econstructor.
         repeat eexists.
         eassumption.
         eauto.
         }
         find_rewrite.
            rewrite Bool.orb_true_r.
            tauto.
   
       ++ (* rpy case *)
   
   
        match goal with
        | H : events _ _ _ _ |- _ => invc H
        end.
       +++
     
   
       assert (term_discloses_to_remote t1 p e (r, H2) = true).
       {
   
       (* left subterm *)
       eapply IHt1 with (p:=p). (* with (H7 := (uu p0 f (asp_paramsC a0 l p1 t) e0)). *)
       econstructor.
       repeat eexists.
       eassumption.
       ff.
       econstructor.
       repeat eexists.
       eassumption.
       eauto.
       }
       find_rewrite.
       simpl.
       tauto.
       +++
           assert (term_discloses_to_remote t2 p mt (r, H2) = true).
       {
   
       (* left subterm *)
       eapply IHt2 with (p:=p). (* with (H7 := (uu p0 f (asp_paramsC a0 l p1 t) e0)). *)
       econstructor.
       repeat eexists.
       eassumption.
       ff.
       econstructor.
       repeat eexists.
       eassumption.
       eauto.
       }
       find_rewrite.
          rewrite Bool.orb_true_r.
          tauto.


    +

          door; subst. 
      
          ++ (* req case *)
            
            match goal with
            | H : events _ _ _ _ |- _ => invc H
            end.
            +++
          
      
            assert (term_discloses_to_remote t1 p mt (r, H2) = true).
            {
      
            (* left subterm *)
            eapply IHt1 with (p:=p). (* with (H7 := (uu p0 f (asp_paramsC a0 l p1 t) e0)). *)
            econstructor.
            repeat eexists.
            eassumption.
            ff.
            econstructor.
            repeat eexists.
            eassumption.
            eauto.
            }
            find_rewrite.
            simpl.
            tauto.
            +++
                assert (term_discloses_to_remote t2 p e (r, H2) = true).
            {
      
            (* left subterm *)
            eapply IHt2 with (p:=p). (* with (H7 := (uu p0 f (asp_paramsC a0 l p1 t) e0)). *)
            econstructor.
            repeat eexists.
            eassumption.
            ff.
            econstructor.
            repeat eexists.
            eassumption.
            eauto.
            }
            find_rewrite.
               rewrite Bool.orb_true_r.
               tauto.
      
          ++ (* rpy case *)
      
      
          match goal with
          | H : events _ _ _ _ |- _ => invc H
          end.
          +++
        
      
          assert (term_discloses_to_remote t1 p mt (r, H2) = true).
          {
      
          (* left subterm *)
          eapply IHt1 with (p:=p). (* with (H7 := (uu p0 f (asp_paramsC a0 l p1 t) e0)). *)
          econstructor.
          repeat eexists.
          eassumption.
          ff.
          econstructor.
          repeat eexists.
          eassumption.
          eauto.
          }
          find_rewrite.
          simpl.
          tauto.
          +++
              assert (term_discloses_to_remote t2 p e (r, H2) = true).
          {
      
          (* left subterm *)
          eapply IHt2 with (p:=p). (* with (H7 := (uu p0 f (asp_paramsC a0 l p1 t) e0)). *)
          econstructor.
          repeat eexists.
          eassumption.
          ff.
          econstructor.
          repeat eexists.
          eassumption.
          eauto.
          }
          find_rewrite.
             rewrite Bool.orb_true_r.
             tauto.

    +

             door; subst. 
         
             ++ (* req case *)
               
          match goal with
          | H : events _ _ _ _ |- _ => invc H
          end.
               +++
         
               assert (term_discloses_to_remote t1 p mt (r, H2) = true).
               {
         
               (* left subterm *)
               eapply IHt1 with (p:=p). (* with (H7 := (uu p0 f (asp_paramsC a0 l p1 t) e0)). *)
               econstructor.
               repeat eexists.
               eassumption.
               ff.
               econstructor.
               repeat eexists.
               eassumption.
               eauto.
               }
               find_rewrite.
               simpl.
               tauto.
               +++
                   assert (term_discloses_to_remote t2 p mt (r, H2) = true).
               {
         
               (* left subterm *)
               eapply IHt2 with (p:=p). (* with (H7 := (uu p0 f (asp_paramsC a0 l p1 t) e0)). *)
               econstructor.
               repeat eexists.
               eassumption.
               ff.
               econstructor.
               repeat eexists.
               eassumption.
               eauto.
               }
               find_rewrite.
                  rewrite Bool.orb_true_r.
                  tauto.
         
             ++ (* rpy case *)
         
         
          match goal with
          | H : events _ _ _ _ |- _ => invc H
          end.
             +++
           
         
             assert (term_discloses_to_remote t1 p mt (r, H2) = true).
             {
         
             (* left subterm *)
             eapply IHt1 with (p:=p). (* with (H7 := (uu p0 f (asp_paramsC a0 l p1 t) e0)). *)
             econstructor.
             repeat eexists.
             eassumption.
             ff.
             econstructor.
             repeat eexists.
             eassumption.
             eauto.
             }
             find_rewrite.
             simpl.
             tauto.
             +++
                 assert (term_discloses_to_remote t2 p mt (r, H2) = true).
             {
         
             (* left subterm *)
             eapply IHt2 with (p:=p). (* with (H7 := (uu p0 f (asp_paramsC a0 l p1 t) e0)). *)
             econstructor.
             repeat eexists.
             eassumption.
             ff.
             econstructor.
             repeat eexists.
             eassumption.
             eauto.
             }
             find_rewrite.
                rewrite Bool.orb_true_r.
                tauto.

    - (* bpar case *)

    match goal with
    | H : annoP _ _ |- _ => invc H
    end.
    destruct_conjs.

    match goal with
    | H : anno _ _ = _ |- _ => invc H
    end.
    repeat break_let.
    ff.

    match goal with
    | H : events_discloses _ _ _ _ _ |- _ => invc H
    end.
    destruct_conjs.
    subst.
    destruct s0; destruct s1; ff.

    +

    door; subst. 

    ++ (* req case *)
      
    match goal with
    | H : events _ _ _ _ |- _ => invc H
    end.
      +++
    

      assert (term_discloses_to_remote t1 p e (r, H2) = true).
      {

      (* left subterm *)
      eapply IHt1 with (p:=p). (* with (H7 := (uu p0 f (asp_paramsC a0 l p1 t) e0)). *)
      econstructor.
      repeat eexists.
      eassumption.
      ff.
      econstructor.
      repeat eexists.
      eassumption.
      eauto.
      }
      find_rewrite.
      simpl.
      tauto.
      +++
          assert (term_discloses_to_remote t2 p e (r, H2) = true).
      {

      (* left subterm *)
      eapply IHt2 with (p:=p). (* with (H7 := (uu p0 f (asp_paramsC a0 l p1 t) e0)). *)
      econstructor.
      repeat eexists.
      eassumption.
      ff.
      econstructor.
      repeat eexists.
      eassumption.
      eauto.
      }
      find_rewrite.
          rewrite Bool.orb_true_r.
          tauto.

    ++ (* rpy case *)


    match goal with
    | H : events _ _ _ _ |- _ => invc H
    end.
    +++
  
    assert (term_discloses_to_remote t1 p e (r, H2) = true).
    {

    (* left subterm *)
    eapply IHt1 with (p:=p). (* with (H7 := (uu p0 f (asp_paramsC a0 l p1 t) e0)). *)
    econstructor.
    repeat eexists.
    eassumption.
    ff.
    econstructor.
    repeat eexists.
    eassumption.
    eauto.
    }
    find_rewrite.
    simpl.
    tauto.
    +++
        assert (term_discloses_to_remote t2 p e (r, H2) = true).
    {

    (* left subterm *)
    eapply IHt2 with (p:=p). (* with (H7 := (uu p0 f (asp_paramsC a0 l p1 t) e0)). *)
    econstructor.
    repeat eexists.
    eassumption.
    ff.
    econstructor.
    repeat eexists.
    eassumption.
    eauto.
    }
    find_rewrite.
        rewrite Bool.orb_true_r.
        tauto.

    +
        door; subst. 
    
        ++ (* req case *)
          
    match goal with
    | H : events _ _ _ _ |- _ => invc H
    end.
          +++
      
          assert (term_discloses_to_remote t1 p e (r, H2) = true).
          {
    
          (* left subterm *)
          eapply IHt1 with (p:=p). (* with (H7 := (uu p0 f (asp_paramsC a0 l p1 t) e0)). *)
          econstructor.
          repeat eexists.
          eassumption.
          ff.
          econstructor.
          repeat eexists.
          eassumption.
          eauto.
          }
          find_rewrite.
          simpl.
          tauto.
          +++
              assert (term_discloses_to_remote t2 p mt (r, H2) = true).
          {
    
          (* left subterm *)
          eapply IHt2 with (p:=p). (* with (H7 := (uu p0 f (asp_paramsC a0 l p1 t) e0)). *)
          econstructor.
          repeat eexists.
          eassumption.
          ff.
          econstructor.
          repeat eexists.
          eassumption.
          eauto.
          }
          find_rewrite.
            rewrite Bool.orb_true_r.
            tauto.
    
        ++ (* rpy case *)
    
    
    match goal with
    | H : events _ _ _ _ |- _ => invc H
    end.
        +++
        
        assert (term_discloses_to_remote t1 p e (r, H2) = true).
        {
    
        (* left subterm *)
        eapply IHt1 with (p:=p). (* with (H7 := (uu p0 f (asp_paramsC a0 l p1 t) e0)). *)
        econstructor.
        repeat eexists.
        eassumption.
        ff.
        econstructor.
        repeat eexists.
        eassumption.
        eauto.
        }
        find_rewrite.
        simpl.
        tauto.
        +++
            assert (term_discloses_to_remote t2 p mt (r, H2) = true).
        {
    
        (* left subterm *)
        eapply IHt2 with (p:=p). (* with (H7 := (uu p0 f (asp_paramsC a0 l p1 t) e0)). *)
        econstructor.
        repeat eexists.
        eassumption.
        ff.
        econstructor.
        repeat eexists.
        eassumption.
        eauto.
        }
        find_rewrite.
          rewrite Bool.orb_true_r.
          tauto.
    +

          door; subst. 
      
          ++ (* req case *)
            
    match goal with
    | H : events _ _ _ _ |- _ => invc H
    end.
            +++
          
            assert (term_discloses_to_remote t1 p mt (r, H2) = true).
            {
      
            (* left subterm *)
            eapply IHt1 with (p:=p). (* with (H7 := (uu p0 f (asp_paramsC a0 l p1 t) e0)). *)
            econstructor.
            repeat eexists.
            eassumption.
            ff.
            econstructor.
            repeat eexists.
            eassumption.
            eauto.
            }
            find_rewrite.
            simpl.
            tauto.
            +++
                assert (term_discloses_to_remote t2 p e (r, H2) = true).
            {
      
            (* left subterm *)
            eapply IHt2 with (p:=p). (* with (H7 := (uu p0 f (asp_paramsC a0 l p1 t) e0)). *)
            econstructor.
            repeat eexists.
            eassumption.
            ff.
            econstructor.
            repeat eexists.
            eassumption.
            eauto.
            }
            find_rewrite.
                rewrite Bool.orb_true_r.
                tauto.
      
          ++ (* rpy case *)
      
      
    match goal with
    | H : events _ _ _ _ |- _ => invc H
    end.
          +++
        
      
          assert (term_discloses_to_remote t1 p mt (r, H2) = true).
          {
      
          (* left subterm *)
          eapply IHt1 with (p:=p). (* with (H7 := (uu p0 f (asp_paramsC a0 l p1 t) e0)). *)
          econstructor.
          repeat eexists.
          eassumption.
          ff.
          econstructor.
          repeat eexists.
          eassumption.
          eauto.
          }
          find_rewrite.
          simpl.
          tauto.
          +++
              assert (term_discloses_to_remote t2 p e (r, H2) = true).
          {
      
          (* left subterm *)
          eapply IHt2 with (p:=p). (* with (H7 := (uu p0 f (asp_paramsC a0 l p1 t) e0)). *)
          econstructor.
          repeat eexists.
          eassumption.
          ff.
          econstructor.
          repeat eexists.
          eassumption.
          eauto.
          }
          find_rewrite.
              rewrite Bool.orb_true_r.
              tauto.

    +
              door; subst. 
          
              ++ (* req case *)
                
    match goal with
    | H : events _ _ _ _ |- _ => invc H
    end.
                +++
                      
                assert (term_discloses_to_remote t1 p mt (r, H2) = true).
                {
          
                (* left subterm *)
                eapply IHt1 with (p:=p). (* with (H7 := (uu p0 f (asp_paramsC a0 l p1 t) e0)). *)
                econstructor.
                repeat eexists.
                eassumption.
                ff.
                econstructor.
                repeat eexists.
                eassumption.
                eauto.
                }
                find_rewrite.
                simpl.
                tauto.
                +++
                    assert (term_discloses_to_remote t2 p mt (r, H2) = true).
                {
          
                (* left subterm *)
                eapply IHt2 with (p:=p). (* with (H7 := (uu p0 f (asp_paramsC a0 l p1 t) e0)). *)
                econstructor.
                repeat eexists.
                eassumption.
                ff.
                econstructor.
                repeat eexists.
                eassumption.
                eauto.
                }
                find_rewrite.
                  rewrite Bool.orb_true_r.
                  tauto.
          
              ++ (* rpy case *)
          
          
    match goal with
    | H : events _ _ _ _ |- _ => invc H
    end.
              +++
            
          
              assert (term_discloses_to_remote t1 p mt (r, H2) = true).
              {
          
              (* left subterm *)
              eapply IHt1 with (p:=p). (* with (H7 := (uu p0 f (asp_paramsC a0 l p1 t) e0)). *)
              econstructor.
              repeat eexists.
              eassumption.
              ff.
              econstructor.
              repeat eexists.
              eassumption.
              eauto.
              }
              find_rewrite.
              simpl.
              tauto.
              +++
                  assert (term_discloses_to_remote t2 p mt (r, H2) = true).
              {
          
              (* left subterm *)
              eapply IHt2 with (p:=p). (* with (H7 := (uu p0 f (asp_paramsC a0 l p1 t) e0)). *)
              econstructor.
              repeat eexists.
              eassumption.
              ff.
              econstructor.
              repeat eexists.
              eassumption.
              eauto.
              }
              find_rewrite.
                rewrite Bool.orb_true_r.
                tauto.
Qed.


Lemma fdfdfd: forall Q P: Prop,
    (P -> Q) ->
    (~Q -> ~P).
Proof.
  intuition.
Qed.

Lemma events_respects_term_disclosure : forall t p q e r annt,
    annoP annt t -> 

  (~ (term_discloses_to_remote t p e (q,r) = true)) ->

  ~ (events_discloses annt p e q r).
Proof.
  intros t p q e r annt H4.
  apply fdfdfd.
  intros.
  eapply term_discloses_respects_events; eauto.
Qed.

(*
Lemma events_respects_term_disclosure_aspid: forall t p e i r annt,
    annoP annt t -> 

  ~ (term_discloses_aspid_to_remote t p e i r) ->

  ~ (events_discloses_aspid annt p e i r).
Proof.
  intros.
  unfold term_discloses_aspid_to_remote in *.
  unfold events_discloses_aspid in *.
  unfold not in H0.
  unfold not in *.
  intros.
  apply H0.
  destruct_conjs.
  exists H1. exists H2.
  split; try eassumption.
  split.
  rewrite evsubt_bool_prop_iff.
  eassumption.

  eapply term_discloses_respects_events; eauto.
Qed.
*)

Lemma events_respects_term_disclosure_aspid_enc : forall t p e i r annt,
    annoP annt t -> 

  ~ (term_discloses_aspid_to_remote_enc t p e i r) ->

  ~ (events_discloses_aspid_enc annt p e i r).
Proof.
  intros.
  unfold term_discloses_aspid_to_remote_enc in *.
  unfold events_discloses_aspid_enc in *.
  unfold not in H0.
  unfold not in *.
  intuition.
  apply H0.
  destruct_conjs.
  eexists.
  split; try eassumption.

  rewrite evsubt_asp_enc_bool_prop_iff.
  eassumption.

  eapply term_discloses_respects_events; eauto.
Qed.

Lemma cvm_respects_events_disclosure:
  forall t e i r atp bits bits' e' cvm_tr cvmi cvmi' annt ac ac',
    
    annoP_indexed annt t cvmi cvmi' ->
    ~ (events_discloses annt (my_abstract_plc (absMan ac)) e i r) ->
    
    term_to_coreP t atp ->
    build_cvmP atp
               (mk_st (evc bits e) [] cvmi ac)
               (resultC tt)
               (mk_st (evc bits' e') cvm_tr cvmi' ac') ->

    ~ (cvm_trace_discloses_to_remote cvm_tr i r).

Proof.
  unfold not in *; intros.
  apply H0.
  invc H3.
  destruct_conjs.
  unfold events_discloses.
  (*exists H4. *) exists x. (* exists H3. exists H5. exists H6. exists H7. *)
  split.
  invc H1.
  eapply cvm_implies_events.
  eassumption.
  eassumption.
  apply H3.
  eassumption.
Qed.

Lemma cvm_respects_term_disclosure :
  forall t e i r atp bits bits' e' cvm_tr cvmi cvmi' annt ac ac',

    annoP_indexed annt t cvmi cvmi' ->

  ~ (term_discloses_to_remote t (my_abstract_plc (absMan ac)) e (r,i) = true) ->
  
  term_to_coreP t atp ->
  build_cvmP atp
             (mk_st (evc bits e) [] cvmi ac)
             (resultC tt)
             (mk_st (evc bits' e') cvm_tr cvmi' ac') ->

  ~ (cvm_trace_discloses_to_remote cvm_tr r i).
Proof.
  intuition.
  eapply cvm_respects_events_disclosure; eauto;
  eapply events_respects_term_disclosure; eauto;
  invc H; econstructor; eauto.
Qed.

Lemma cvm_respects_events_disclosure_aspid_enc:
forall t e i r atp bits bits' e' cvm_tr cvmi cvmi' annt ac ac',
  
  annoP_indexed annt t cvmi cvmi' ->
  ~ (events_discloses_aspid_enc annt (my_abstract_plc (absMan ac)) e i r) ->
  
  term_to_coreP t atp ->
  build_cvmP atp
              (mk_st (evc bits e) [] cvmi ac)
              (resultC tt)
              (mk_st (evc bits' e') cvm_tr cvmi' ac') ->

  ~ (cvm_trace_discloses_aspid_to_remote_enc cvm_tr i r).

Proof.
  unfold not in *; intros.
  apply H0.
  invc H3.
  destruct_conjs.
  unfold events_discloses_aspid_enc.
  (*exists H4. *) exists x. (* exists H3. exists H5. exists H6. exists H7. *)
  split.
  eassumption.
  invc H4.
  destruct_conjs.

  invc H1.

  econstructor.
  (* exists H5. exists H4. exists H6. *)
  split; eauto.
  eapply cvm_implies_events; eauto.
Qed.


Lemma cvm_respects_term_disclosure_aspid_enc :
  forall t e i r atp bits bits' e' cvm_tr cvmi cvmi' annt ac ac',

    annoP_indexed annt t cvmi cvmi' ->

  ~ (term_discloses_aspid_to_remote_enc t (my_abstract_plc (absMan ac)) e i r) ->
  
  term_to_coreP t atp ->
  build_cvmP atp
             (mk_st (evc bits e) [] cvmi ac)
             (resultC tt)
             (mk_st (evc bits' e') cvm_tr cvmi' ac') ->

  ~ (cvm_trace_discloses_aspid_to_remote_enc cvm_tr i r).
Proof.
  intros.
  
  eapply cvm_respects_events_disclosure_aspid_enc; eauto.
  eapply events_respects_term_disclosure_aspid_enc; eauto.
  invc H; eauto.
  econstructor; eauto.
Qed.






(** Extra term_disloses* defs (may be deprecated...): 




(*

Lemma term_disc_remote: forall t p e i r p0,
          term_discloses_aspid_to_remote t p e i r ->
          term_discloses_aspid_to_remote <{ @ p [t] }> p0 e i r.
Proof.
  intros.
  invc H.
  destruct_conjs.
  econstructor.
  exists H0.
  split.
  -
    eassumption.
  -
    simpl in *.
    destruct x; try solve_by_inversion.
    destruct a; try solve_by_inversion.
    assert (a = i).
    {
      assert (eqb a i = true).
      {
        repeat rewrite Bool.andb_true_r in H.
        auto.
      }
      eapply eqb_eq_aspid; eauto.
    }
    
    subst.
    find_rewrite.
    rewrite Bool.orb_true_r.
    auto.
Qed.
*)


(*
Lemma term_disc_lseq_l: forall t1 t2 p e i r,
          term_discloses_aspid_to_remote t1 p e i r ->
          term_discloses_aspid_to_remote <{ t1 -> t2 }> p e i r.
Proof.
  intros.
  invc H.
  destruct_conjs.
  econstructor.
  exists H0.
  split.
  -
    eassumption.
  -
    simpl in *.
    destruct x; try solve_by_inversion.
    destruct a; try solve_by_inversion.
    assert (a = i).
    {
      assert (eqb a i = true).
      {
        repeat rewrite Bool.andb_true_r in H.
        auto.
      }
      eapply eqb_eq_aspid; eauto.
    }
    
    subst.
    find_rewrite.
    rewrite Bool.orb_true_l.
    auto.
Qed.
*)


(*
Lemma term_disc_lseq_r: forall t1 t2 p e i r,
          term_discloses_aspid_to_remote t2 p (eval t1 p e) i r ->
          term_discloses_aspid_to_remote <{ t1 -> t2 }> p e i r.
Proof.
  intros.
  invc H.
  destruct_conjs.
  econstructor.
  exists H0.
  split.
  -
    eassumption.
  -
    simpl in *.
    destruct x; try solve_by_inversion.
    destruct a; try solve_by_inversion.
    assert (a = i).
    {
      assert (eqb a i = true).
      {
        repeat rewrite Bool.andb_true_r in H.
        auto.
      }
      eapply eqb_eq_aspid; eauto.
    }
    
    subst.
    find_rewrite.
    rewrite Bool.orb_true_r.
    auto.
Qed.
*)


(*

Lemma term_disc_bseq_l: forall t1 t2 p e i r s,
          term_discloses_aspid_to_remote t1 p (splitEv_T_l s e) i r ->
          term_discloses_aspid_to_remote (bseq s t1 t2) p e i r.
Proof.
  intros.
  invc H.
  destruct_conjs.
  econstructor.
  exists H0.
  split.
  -
    eassumption.
  -
    simpl in *.
    destruct x; try solve_by_inversion.
    destruct a; try solve_by_inversion.
    assert (a = i).
    {
      assert (eqb a i = true).
      {
        repeat rewrite Bool.andb_true_r in H.
        auto.
      }
      eapply eqb_eq_aspid; eauto.
    }
    
    subst.
    destruct s.
    destruct s;
      
      simpl in *;
      rewrite H2;
      
      rewrite Bool.orb_true_l;
      auto.
Qed.
*)

(*
Lemma term_disc_bseq_r: forall t1 t2 p e i r s,
          term_discloses_aspid_to_remote t2 p (splitEv_T_r s e) i r ->
          term_discloses_aspid_to_remote (bseq s t1 t2) p e i r.
Proof.
  intros.
  invc H.
  destruct_conjs.
  econstructor.
  exists H0.
  split.
  -
    eassumption.
  -
    simpl in *.
    destruct x; try solve_by_inversion.
    destruct a; try solve_by_inversion.
    assert (a = i).
    {
      assert (eqb a i = true).
      {
        repeat rewrite Bool.andb_true_r in H.
        auto.
      }
      eapply eqb_eq_aspid; eauto.
    }
    
    subst.
    destruct s;
      destruct s;
      destruct s0;

      simpl in *;
      rewrite H2;
      
      rewrite Bool.orb_true_r;
      auto.
Qed.
*)

(*
Lemma term_disc_bpar_l: forall t1 t2 p e i r s,
          term_discloses_aspid_to_remote t1 p (splitEv_T_l s e) i r ->
          term_discloses_aspid_to_remote (bpar s t1 t2) p e i r.
Proof.
  intros.
  invc H.
  destruct_conjs.
  econstructor.
  exists H0.
  split.
  -
    eassumption.
  -
    simpl in *.
    destruct x; try solve_by_inversion.
    destruct a; try solve_by_inversion.
    assert (a = i).
    {
      assert (eqb a i = true).
      {
        repeat rewrite Bool.andb_true_r in H.
        auto.
      }
      eapply eqb_eq_aspid; eauto.
    }
    
    subst.
    destruct s;
      destruct s;
      destruct s0;

      simpl in *;
      rewrite H2;
      
      rewrite Bool.orb_true_l;
      auto.
Qed.
*)

(*
Lemma term_disc_bpar_r: forall t1 t2 p e i r s,
          term_discloses_aspid_to_remote t2 p (splitEv_T_r s e) i r ->
          term_discloses_aspid_to_remote (bpar s t1 t2) p e i r.
Proof.
  intros.
  invc H.
  destruct_conjs.
  econstructor.
  exists H0.
  split.
  -
    eassumption.
  -
    simpl in *.
    destruct x; try solve_by_inversion.
    destruct a; try solve_by_inversion.
    assert (a = i).
    {
      assert (eqb a i = true).
      {
        repeat rewrite Bool.andb_true_r in H.
        auto.
      }
      eapply eqb_eq_aspid; eauto.
    }
    
    subst.
    destruct s;
      destruct s;
      destruct s0;

      simpl in *;
      rewrite H2;
      
      rewrite Bool.orb_true_r;
      auto.
Qed.
*)









*)